{"diff": "a / lib / Sema / TypeCheckDecl . cpp \n  b / lib / Sema / TypeCheckDecl . cpp \n static void finalizeType ( TypeChecker & TC , NominalTypeDecl * nominal ) { \n \n TC . validateDecl ( VD ) ; \n \n + TC . requestMemberLayout ( VD ) ; \n + \n / / The only thing left to do is synthesize storage for lazy variables . \n auto * prop = dyn_cast < VarDecl > ( D ) ; \n if ( ! prop )", "msg": "[ Type checker ] Request member layout for a member of a finalized type .\n"}
{"diff": "a / Marlin / src / module / tool_change . cpp \n  b / Marlin / src / module / tool_change . cpp \n void tool_change ( const uint8_t tmp_extruder , const float fr_mm_s / * = 0 . 0 * / , bool n \n if ( ! DEBUGGING ( DRYRUN ) & & thermalManager . targetTooColdToExtrude ( active_extruder ) ) { \n SERIAL_ERROR_START ( ) ; \n SERIAL_ERRORLNPGM ( MSG_HOTEND_TOO_COLD ) ; \n + active_extruder = tmp_extruder ; \n return ; \n } \n # endif", "msg": "Allow cold change of active extruder ( )\n"}
{"diff": "a / src / app / script / app_object . cpp \n  b / src / app / script / app_object . cpp \n int App_set_activeLayer ( lua_State * L ) \n \n int App_set_activeFrame ( lua_State * L ) \n { \n - const doc : : frame_t frame = lua_tointeger ( L , 2 ) - 1 ; \n + const doc : : frame_t frame = get_frame_number_from_arg ( L , 2 ) ; \n # ifdef ENABLE_UI \n app : : Context * ctx = App : : instance ( ) - > context ( ) ; \n if ( auto uiCtx = dynamic_cast < UIContext * > ( ctx ) ) {", "msg": "lua : Add support to use app . activeFrame with a Frame object\n"}
{"diff": "a / Code / CryEngine / CryAudioSystem / ATLAudioObject . cpp \n  b / Code / CryEngine / CryAudioSystem / ATLAudioObject . cpp \n void CATLAudioObject : : Update ( \n m_propagationProcessor . GetPropagationData ( propagationData ) ; \n m_pImplData - > SetObstructionOcclusion ( propagationData . obstruction , propagationData . occlusion ) ; \n } \n + \n + UpdateControls ( deltaTime , distanceToListener , listenerPosition , listenerVelocity , listenerMoved ) ; \n + m_pImplData - > Update ( ) ; \n } \n \n / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / /", "msg": "! XB ( Audio ) Fixed merge issue of CL 1631770\n"}
{"diff": "a / lib / IRGen / IRGenDebugInfo . cpp \n  b / lib / IRGen / IRGenDebugInfo . cpp \n \n # include \" llvm / Config / config . h \" \n # include \" llvm / IR / DIBuilder . h \" \n # include \" llvm / IR / DebugInfo . h \" \n + # include \" llvm / IR / IntrinsicInst . h \" \n # include \" llvm / IR / Module . h \" \n # include \" llvm / Support / CommandLine . h \" \n # include \" llvm / Support / Debug . h \" \n void IRGenDebugInfoImpl : : emitDbgIntrinsic ( \n auto * BB = Builder . GetInsertBlock ( ) ; \n \n / / An alloca may only be described by exactly one dbg . declare . \n - if ( isa < llvm : : AllocaInst > ( Storage ) & & llvm : : FindAllocaDbgDeclare ( Storage ) ) \n + if ( isa < llvm : : AllocaInst > ( Storage ) & & ! llvm : : FindDbgAddrUses ( Storage ) . empty ( ) ) \n return ; \n \n / / A dbg . declare is only meaningful if there is a single alloca for", "msg": "master - next : Update IRGenDebugInfo . cpp for LLVM r313825\n"}
{"diff": "a / UnitTests / Basics / PathEnumeratorTest . cpp \n  b / UnitTests / Basics / PathEnumeratorTest . cpp \n BOOST_FIXTURE_TEST_SUITE ( PathEnumeratorTest , PathEnumeratorSetup ) \n \n BOOST_AUTO_TEST_CASE ( test_fullPathEnumerator ) { \n int startVertex = 1 ; \n - PathEnumerator < int , int , int > it ( integerEdgeEnumerator , integerVertexEnumerator , startVertex ) ; \n + DepthFirstEnumerator < int , int , int > it ( integerEdgeEnumerator , integerVertexEnumerator , startVertex ) ; \n EnumeratedPath < int , int > path ; \n for ( int k = 1 ; k < 4 ; k + + ) { \n path = it . next ( ) ;", "msg": "Adapted test of PathEnumerator to DepthFirstEnumerator .\n"}
{"diff": "a / DataReader / SparsePCReader / SparsePCReader . cpp \n  b / DataReader / SparsePCReader / SparsePCReader . cpp \n void SparsePCReader < ElemType > : : Init ( const ConfigParameters & readerConfig ) \n m_microBatchSize = readerConfig ( \" microbatchSize \" , \" 1 \" ) ; \n \n m_miniBatchSize = 0 ; \n + m_microBatchSize = readerConfig ( \" microbatchSize \" , \" 1 \" ) ; \n m_traceLevel = readerConfig ( \" traceLevel \" , \" 0 \" ) ; \n m_maxReadData = readerConfig ( \" maxReadData \" , \" 0 \" ) ; \n m_doGradientCheck = readerConfig ( \" gradientCheck \" , \" false \" ) ; \n bool SparsePCReader < ElemType > : : GetMinibatch ( std : : map < std : : wstring , Matrix < ElemTy \n return false ; \n } \n \n + m_pMBLayout - > Init ( m_miniBatchSize / m_microBatchSize , m_microBatchSize , false ) ; \n + \n Matrix < ElemType > * labels = nullptr ; \n auto labelEntry = matrices . find ( m_labelName ) ; \n bool useLabels = false ;", "msg": "Adding layout handling to SparsePCReader .\n"}
{"diff": "a / src / FilterTableHeader . cpp \n  b / src / FilterTableHeader . cpp \n FilterTableHeader : : FilterTableHeader ( QTableView * parent ) : \n / / Make sure to not automatically resize the columns according to the contents \n setSectionResizeMode ( QHeaderView : : Interactive ) ; \n \n + / / Highlight column headers of selected cells to emulate spreadsheet behaviour \n + setHighlightSections ( true ) ; \n + \n / / Do some connects : Basically just resize and reposition the input widgets whenever anything changes \n connect ( this , & FilterTableHeader : : sectionResized , this , & FilterTableHeader : : adjustPositions ) ; \n connect ( parent - > horizontalScrollBar ( ) , & QScrollBar : : valueChanged , this , & FilterTableHeader : : adjustPositions ) ;", "msg": "Highlight column headers to emulate spreadsheet behaviour\n"}
{"diff": "a / xbmc / music / MusicDatabase . cpp \n  b / xbmc / music / MusicDatabase . cpp \n bool CMusicDatabase : : GetAlbumsByWhere ( const CStdString & baseDir , const CStdStrin \n int idAlbum = m_pDS - > fv ( \" idAlbum \" ) . get_asInt ( ) ; \n strDir . Format ( \" % s % ld / \" , baseDir . c_str ( ) , idAlbum ) ; \n CFileItemPtr pItem ( new CFileItem ( strDir , GetAlbumFromDataset ( m_pDS . get ( ) ) ) ) ; \n + pItem - > SetIconImage ( \" DefaultAlbumCover . png \" ) ; \n items . Add ( pItem ) ; \n m_pDS - > next ( ) ; \n }", "msg": "added : set Music Album fallback icon to \" DefaultAlbumCover . png \"\n"}
{"diff": "a / Code / CryEngine / RenderDll / XRenderD3D9 / GraphicsPipeline / ShadowMap . cpp \n  b / Code / CryEngine / RenderDll / XRenderD3D9 / GraphicsPipeline / ShadowMap . cpp \n void CShadowMapStage : : ReAllocateResources ( const SShadowConfig shadowConfig ) \n if ( ! pTx ) \n { \n char szName [ 64 ] ; \n - cry_sprintf ( szName , \" % CachedShadowMap_ % d \" , i ) ; \n + cry_sprintf ( szName , \" $ ShadowMapCached_ % d \" , i ) ; \n \n pTx = CTexture : : GetOrCreateDepthStencil ( szName , nResolutions [ i ] , nResolutions [ i ] , Clr_FarPlane , eTT_2D , FT_DONT_STREAM , texFormat ) ; \n }", "msg": "! B ( Renderer ) Fixed malformed texture - name\n"}
{"diff": "a / Marlin / Marlin_main . cpp \n  b / Marlin / Marlin_main . cpp \n inline void gcode_G92 ( ) { \n current_position [ i ] = code_value_axis_units ( i ) ; \n if ( i ! = E_AXIS ) didXYZ = true ; \n # else \n - float p = current_position [ i ] , \n - v = code_value_axis_units ( i ) ; \n + # if DISABLED ( NO_WORKSPACE_OFFSETS ) \n + float p = current_position [ i ] ; \n + # endif \n + float v = code_value_axis_units ( i ) ; \n \n current_position [ i ] = v ;", "msg": "prevent warning with define of NO_WORKSPACE_OFFSETS\n"}
{"diff": "a / src / input_common / sdl / sdl_impl . cpp \n  b / src / input_common / sdl / sdl_impl . cpp \n SDLState : : SDLState ( ) { \n if ( start_thread ) { \n poll_thread = std : : thread ( [ & ] { \n using namespace std : : chrono_literals ; \n - SDL_Event event ; \n while ( initialized ) { \n SDL_PumpEvents ( ) ; \n std : : this_thread : : sleep_for ( std : : chrono : : duration ( 10ms ) ) ;", "msg": "input_common / sdl_impl : Remove unused variable in SDLState constructor\n"}
{"diff": "a / modules / features2d / src / blobdetector . cpp \n  b / modules / features2d / src / blobdetector . cpp \n void SimpleBlobDetector : : detectImpl ( const cv : : Mat & image , std : : vector < cv : : KeyPoi \n KeyPoint kpt ( sumPoint , ( float ) params . defaultKeypointSize ) ; \n keypoints . push_back ( kpt ) ; \n } \n + \n + # ifdef DEBUG_BLOB_DETECTOR \n + namedWindow ( \" keypoints \" , CV_WINDOW_NORMAL ) ; \n + Mat outImg = image . clone ( ) ; \n + for ( size_t i = 0 ; i < keypoints . size ( ) ; i + + ) \n + { \n + circle ( outImg , keypoints [ i ] . pt , 2 , Scalar ( 255 , 0 , 255 ) , - 1 ) ; \n + } \n + / / drawKeypoints ( image , keypoints , outImg ) ; \n + imshow ( \" keypoints \" , outImg ) ; \n + waitKey ( ) ; \n + # endif \n }", "msg": "Added drawing of a new image for debugging of the SimpleBlobDetector class .\n"}
{"diff": "a / tools / editor / io_plugins / editor_font_import_plugin . cpp \n  b / tools / editor / io_plugins / editor_font_import_plugin . cpp \n class EditorFontImportDialog : public ConfirmationDialog { \n return ; \n } \n \n + if ( dest - > get_line_edit ( ) - > get_text ( ) . get_file ( ) = = \" . fnt \" ) { \n + dest - > get_line_edit ( ) - > set_text ( dest - > get_line_edit ( ) - > get_text ( ) . get_base_dir ( ) + \" / \" + source - > get_line_edit ( ) - > get_text ( ) . get_file ( ) . basename ( ) + \" . fnt \" ) ; \n + } \n + \n Ref < ResourceImportMetadata > rimd = get_rimd ( ) ; \n \n if ( rimd . is_null ( ) ) {", "msg": "Set default destination filename of imported font to be input font filename\n"}
{"diff": "a / lib / FrontendTool / FrontendTool . cpp \n  b / lib / FrontendTool / FrontendTool . cpp \n static bool validateTBDIfNeeded ( CompilerInvocation & Invocation , \n switch ( mode ) { \n case FrontendOptions : : TBDValidationMode : : Default : \n # ifndef NDEBUG \n - / / When a debug compiler is targeting an apple platform , we do some \n - / / validation by default . \n - if ( Invocation . getLangOptions ( ) . Target . getVendor ( ) = = llvm : : Triple : : Apple ) { \n - mode = FrontendOptions : : TBDValidationMode : : MissingFromTBD ; \n - break ; \n - } \n - # endif \n + / / With a debug compiler , we do some validation by default . \n + mode = FrontendOptions : : TBDValidationMode : : MissingFromTBD ; \n + break ; \n + # else \n / / Otherwise , the default is to do nothing . \n LLVM_FALLTHROUGH ; \n + # endif \n case FrontendOptions : : TBDValidationMode : : None : \n return false ; \n case FrontendOptions : : TBDValidationMode : : All :", "msg": "[ TBD ] Validate TBDs in debug compilers for all platforms .\n"}
{"diff": "a / src / mainwindow . cpp \n  b / src / mainwindow . cpp \n void MainWindow : : setupUi ( ) \n dataTable - > setRowCount ( 0 ) ; \n dataTable - > setColumnCount ( 0 ) ; \n dataTable - > setSelectionMode ( QTableWidget : : SingleSelection ) ; \n + dataTable - > setHorizontalScrollMode ( QAbstractItemView : : ScrollPerPixel ) ; \n \n vboxLayout2 - > addWidget ( dataTable ) ; \n \n void MainWindow : : setupUi ( ) \n queryResultTableView - > setSelectionMode ( QTreeView : : NoSelection ) ; \n queryResultTableView - > setModel ( queryResultListModel ) ; \n queryResultTableView - > setEditTriggers ( QAbstractItemView : : NoEditTriggers ) ; \n + queryResultTableView - > setHorizontalScrollMode ( QAbstractItemView : : ScrollPerPixel ) ; \n \n vboxLayout3 - > addWidget ( queryResultTableView ) ;", "msg": "set horizontal scrollmode of result widgets to per pixel\n"}
{"diff": "a / src / mongo / util / descriptive_stats_test . cpp \n  b / src / mongo / util / descriptive_stats_test . cpp \n \n + / * * \n + * Copyright ( C ) 2012 10gen Inc . \n + * \n + * This program is free software : you can redistribute it and / or modify \n + * it under the terms of the GNU Affero General Public License , version 3 , \n + * as published by the Free Software Foundation . \n + * \n + * This program is distributed in the hope that it will be useful , \n + * but WITHOUT ANY WARRANTY ; without even the implied warranty of \n + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the \n + * GNU Affero General Public License for more details . \n + * \n + * You should have received a copy of the GNU Affero General Public License \n + * along with this program . If not , see < http : / / www . gnu . org / licenses / > . \n + * / \n + \n / * * \n * Tests for mongo / util / descriptive_stats . h \n * /", "msg": "Add copyright notice to fix lint failure\n"}
{"diff": "a / scene / gui / text_edit . cpp \n  b / scene / gui / text_edit . cpp \n void TextEdit : : _update_completion_candidates ( ) { \n int ci_match = 0 ; \n Vector < float > sim_cache ; \n for ( int i = 0 ; i < completion_strings . size ( ) ; i + + ) { \n + if ( s = = completion_strings [ i ] ) { \n + / / A perfect match , stop completion \n + _cancel_completion ( ) ; \n + return ; \n + } \n if ( s . is_subsequence_ofi ( completion_strings [ i ] ) ) { \n / / don ' t remove duplicates if no input is provided \n if ( s ! = \" \" & & completion_options . find ( completion_strings [ i ] ) ! = - 1 ) {", "msg": "Stop completion when the match is perfect\n"}
{"diff": "a / src / gui / Src / Gui / MainWindow . cpp \n  b / src / gui / Src / Gui / MainWindow . cpp \n MainWindow : : MainWindow ( QWidget * parent ) \n makeCommandAction ( ui - > actioneStepInto , \" eStepInto \" ) ; \n makeCommandAction ( ui - > actioneRun , \" eRun \" ) ; \n makeCommandAction ( ui - > actioneRtr , \" eRtr \" ) ; \n - makeCommandAction ( ui - > actionRtu , \" rtu \" ) ; \n + makeCommandAction ( ui - > actionRtu , \" TraceIntoConditional ! mod . party ( cip ) \" ) ; \n connect ( ui - > actionTicnd , SIGNAL ( triggered ( ) ) , this , SLOT ( execTicnd ( ) ) ) ; \n connect ( ui - > actionTocnd , SIGNAL ( triggered ( ) ) , this , SLOT ( execTocnd ( ) ) ) ; \n connect ( ui - > actionTRBit , SIGNAL ( triggered ( ) ) , this , SLOT ( execTRBit ( ) ) ) ;", "msg": "GUI : conditional tracing instead of rtu in run to user code\n"}
{"diff": "a / lib / AST / Type . cpp \n  b / lib / AST / Type . cpp \n static Type getMemberForBaseType ( LookupConformanceFn lookupConformances , \n \n if ( ! conformance ) return failed ( ) ; \n if ( ! conformance - > isConcrete ( ) ) return failed ( ) ; \n - assert ( conformance - > getConditionalRequirements ( ) . empty ( ) & & \n - \" unhandled conditional requirements \" ) ; \n \n / / Retrieve the type witness . \n auto witness =", "msg": "[ AST ] Remove another bogus assertion .\n"}
{"diff": "a / folly / experimental / coro / tests / CoroTest . cpp \n  b / folly / experimental / coro / tests / CoroTest . cpp \n \n * limitations under the License . \n * / \n \n + # include < folly / Portability . h > \n + \n # if FOLLY_HAS_COROUTINES \n \n # include < folly / executors / ManualExecutor . h >", "msg": "Include Portability . h before using FOLLY_HAS_COROUTINES\n"}
{"diff": "a / src / taichi_llvm_context . cpp \n  b / src / taichi_llvm_context . cpp \n TLANG_NAMESPACE_BEGIN \n static llvm : : ExitOnError exit_on_err ; \n \n TaichiLLVMContext : : TaichiLLVMContext ( ) { \n - return ; \n llvm : : InitializeNativeTarget ( ) ; \n llvm : : InitializeNativeTargetAsmPrinter ( ) ; \n llvm : : InitializeNativeTargetAsmParser ( ) ;", "msg": "reenable llvm after fixing glibc ABI version issue on Ubuntu\n"}
{"diff": "a / imgui . cpp \n  b / imgui . cpp \n static ImVec2 CalcSizeAutoFit ( ImGuiWindow * window ) \n if ( size_auto_fit_after_constraint . x < window - > SizeContents . x & & ! ( flags & ImGuiWindowFlags_NoScrollbar ) & & ( flags & ImGuiWindowFlags_HorizontalScrollbar ) ) \n size_auto_fit . y + = style . ScrollbarSize ; \n if ( size_auto_fit_after_constraint . y < window - > SizeContents . y & & ! ( flags & ImGuiWindowFlags_NoScrollbar ) ) \n - size_auto_fit . x + = style . ScrollbarSize * 2 . 0f ; \n + size_auto_fit . x + = style . ScrollbarSize ; \n size_auto_fit . y = ImMax ( size_auto_fit . y - style . ItemSpacing . y , 0 . 0f ) ; \n } \n return size_auto_fit ;", "msg": "Fixed auto - resize allocating too much space for scrollbar when SizeContents is bigger than maximum window size ( fixes c0547d358d746699f8d46a4996e49fdac8c55748 ) ( )\n"}
{"diff": "a / src / RowLoader . cpp \n  b / src / RowLoader . cpp \n void RowLoader : : process ( Task & t ) \n sqlite3_finalize ( stmt ) ; \n } \n \n - if ( row ! = t . row_begin ) \n - emit fetched ( t . token , t . row_begin , row ) ; \n + emit fetched ( t . token , t . row_begin , row ) ; \n }", "msg": "Send the fetched signal in RowLoader even when no rows where fetched\n"}
{"diff": "a / db / repl / rs_config . cpp \n  b / db / repl / rs_config . cpp \n namespace mongo { \n / * TODO : use of string exceptions may be problematic for reconfig case ! * / \n throw \" _id must be numeric \" ; \n } \n - string s ; \n try { \n - s = mobj [ \" host \" ] . String ( ) ; \n + string s = mobj [ \" host \" ] . String ( ) ; \n m . h = HostAndPort ( s ) ; \n + if ( ! m . h . hasPort ( ) ) { \n + m . h . setPort ( m . h . port ( ) ) ; \n + } \n } \n catch ( . . . ) { \n throw string ( \" bad or missing host field ? \" ) + mobj . toString ( ) ;", "msg": "always set port when for rs config\n"}
{"diff": "a / db / mr . cpp \n  b / db / mr . cpp \n namespace mongo { \n if ( values . size ( ) ) \n db . insert ( fulloutput , reduceValues ( values , s . get ( ) , reduceFunction ) ) ; \n \n + for ( set < ServerAndQuery > : : iterator i = servers . begin ( ) ; i ! = servers . end ( ) ; i + + ) { \n + ScopedDbConnection conn ( i - > _server ) ; \n + conn - > dropCollection ( dbname + \" . \" + shardedOutputCollection ) ; \n + } \n \n return 1 ; \n }", "msg": "delete temp shard collections on shards SHARDING - 37\n"}
{"diff": "a / s / d_state . cpp \n  b / s / d_state . cpp \n namespace mongo { \n BSONObj d = cursor - > next ( ) ; \n \n if ( min . isEmpty ( ) ) { \n - min = d [ \" min \" ] . Obj ( ) ; \n - max = d [ \" max \" ] . Obj ( ) ; \n + min = d [ \" min \" ] . Obj ( ) . getOwned ( ) ; \n + max = d [ \" max \" ] . Obj ( ) . getOwned ( ) ; \n continue ; \n } \n \n if ( max = = d [ \" min \" ] . Obj ( ) ) { \n - max = d [ \" max \" ] . Obj ( ) ; \n + max = d [ \" max \" ] . Obj ( ) . getOwned ( ) ; \n continue ; \n } \n \n p - > gotRange ( min . getOwned ( ) , max . getOwned ( ) ) ; \n - min = d [ \" min \" ] . Obj ( ) ; \n - max = d [ \" max \" ] . Obj ( ) ; \n + min = d [ \" min \" ] . Obj ( ) . getOwned ( ) ; \n + max = d [ \" max \" ] . Obj ( ) . getOwned ( ) ; \n } \n assert ( ! min . isEmpty ( ) ) ; \n p - > gotRange ( min . getOwned ( ) , max . getOwned ( ) ) ;", "msg": "getOwned ( ) on all cursor objects\n"}
{"diff": "a / folly / synchronization / test / BarrierTest . cpp \n  b / folly / synchronization / test / BarrierTest . cpp \n \n \n # include < folly / portability / GTest . h > \n \n - using namespace folly ; \n using namespace folly : : test ; \n \n class BarrierTest : public testing : : Test { } ;", "msg": "Remove dead includes in folly / synchronization\n"}
{"diff": "a / Marlin / ultralcd . cpp \n  b / Marlin / ultralcd . cpp \n static void lcd_main_menu ( ) { \n END_MENU ( ) ; \n } \n \n - # if ENABLED ( SDSUPPORT ) & & ENABLED ( MENU_ADDAUTOSTART ) \n - static void lcd_autostart_sd ( ) { \n - card . autostart_index = 0 ; \n - card . setroot ( ) ; \n - card . checkautostart ( true ) ; \n - } \n - # endif \n \n / * * \n * Set the home offset based on the current_position \n void lcd_cooldown ( ) { \n lcd_return_to_status ( ) ; \n } \n \n + # if ENABLED ( SDSUPPORT ) & & ENABLED ( MENU_ADDAUTOSTART ) \n + \n + static void lcd_autostart_sd ( ) { \n + card . autostart_index = 0 ; \n + card . setroot ( ) ; \n + card . checkautostart ( true ) ; \n + } \n + \n + # endif \n / * * \n * \n * \" Prepare \" submenu", "msg": "Move lcd_autostart_sd to its logical place\n"}
{"diff": "a / flow / Platform . cpp \n  b / flow / Platform . cpp \n void setMemoryQuota ( size_t limit ) { \n } \n if ( ! AssignProcessToJobObject ( job , GetCurrentProcess ( ) ) ) \n TraceEvent ( SevWarn , \" FailedToSetMemoryLimit \" ) . GetLastError ( ) ; \n - # elif defined ( __linux__ ) \n + # elif defined ( __linux__ ) & & ! defined ( USE_ASAN ) \n struct rlimit rlim ; \n if ( getrlimit ( RLIMIT_AS , & rlim ) ) { \n TraceEvent ( SevError , \" GetMemoryLimit \" ) . GetLastError ( ) ;", "msg": "disable rlimit when ASAN is used\n"}
{"diff": "a / xbmc / cores / dvdplayer / DVDCodecs / Video / CrystalHD . cpp \n  b / xbmc / cores / dvdplayer / DVDCodecs / Video / CrystalHD . cpp \n void CMPCOutputThread : : CopyOutAsNV12 ( CPictureBuffer * pBuffer , BCM : : BC_DTS_PROC_O \n } \n } \n \n - # if 0 \n + # if _WIN32 \n / / Taken from Xine Project ( color . c ) \n / / Copyright ( C ) 2000 - 2003 the xine project \n / / GNU General Public License version 2 of the License ,", "msg": "[ chd ] use c routines for yuy2 to yv12 convert under win platform\n"}
{"diff": "a / db / db . cpp \n  b / db / db . cpp \n namespace mongo { \n break ; \n } \n \n + if ( inShutdown ( ) ) { \n + log ( ) < < \" got request after shutdown ( ) \" < < endl ; \n + break ; \n + } \n + \n lastError . startRequest ( m , le ) ; \n \n DbResponse dbresponse ;", "msg": "checking inShutdown ( ) when recv a message\n"}
{"diff": "a / src / base / preferences . cpp \n  b / src / base / preferences . cpp \n void Preferences : : setRssHSplitterState ( const QByteArray & state ) \n QByteArray Preferences : : getRssVSplitterState ( ) const \n { \n # ifdef QBT_USES_QT5 \n - return value ( \" Rss / qt5 / splitter_v \" ) . toByteArray ( ) ; \n + return value ( \" Rss / qt5 / splitterV \" ) . toByteArray ( ) ; \n # else \n - return value ( \" Rss / splitter_v \" ) . toByteArray ( ) ; \n + return value ( \" Rss / splitterV \" ) . toByteArray ( ) ; \n # endif \n } \n \n void Preferences : : setRssVSplitterState ( const QByteArray & state ) \n { \n # ifdef QBT_USES_QT5 \n - setValue ( \" Rss / qt5 / splitter_v \" , state ) ; \n + setValue ( \" Rss / qt5 / splitterV \" , state ) ; \n # else \n - setValue ( \" Rss / splitter_v \" , state ) ; \n + setValue ( \" Rss / splitterV \" , state ) ; \n # endif \n }", "msg": "Use new key for storing RSS splitter_v value .\n"}
{"diff": "a / lib / Driver / ToolChains . cpp \n  b / lib / Driver / ToolChains . cpp \n toolchains : : GenericUnix : : constructInvocation ( const LinkJobAction & job , \n Arguments . push_back ( context . Args . MakeArgString ( A - > getValue ( ) ) ) ; \n } \n \n - if ( getTriple ( ) . getOS ( ) = = llvm : : Triple : : Linux ) { \n + if ( getTriple ( ) . getOS ( ) = = llvm : : Triple : : Linux & & ! getTriple ( ) . isAndroid ( ) ) { \n Arguments . push_back ( \" - pie \" ) ; \n }", "msg": "Avoid adding - pie on Android apps which are - shared\n"}
{"diff": "a / Telegram / SourceFiles / history / history_item . cpp \n  b / Telegram / SourceFiles / history / history_item . cpp \n bool HistoryItem : : canDeleteForEveryone ( TimeId now ) const { \n return false ; \n } \n } \n - if ( ! peer - > isUser ( ) & & ! toHistoryMessage ( ) ) { \n - return false ; \n - } else if ( const auto media = this - > media ( ) ) { \n + if ( const auto media = this - > media ( ) ) { \n if ( ! media - > allowsRevoke ( now ) ) { \n return false ; \n }", "msg": "Allow in groups to delete service messages for everyone .\n"}
{"diff": "a / xbmc / PlayListPlayer . cpp \n  b / xbmc / PlayListPlayer . cpp \n bool CPlayListPlayer : : Play ( int iSong , bool bAutoPlay / * = false * / , bool bPlayPr \n } \n } \n \n + / / reset the start offset of this item \n + if ( item - > m_lStartOffset = = STARTOFFSET_RESUME ) \n + item - > m_lStartOffset = 0 ; \n + \n / / TODO - move the above failure logic and the below success logic \n / / to callbacks instead so we don ' t rely on the return value \n / / of PlayFile ( )", "msg": "reset resume point after playing items via the playlist player , so that when they repeat the start at the beginning . fixes\n"}
{"diff": "a / lib / Sema / PlaygroundTransform . cpp \n  b / lib / Sema / PlaygroundTransform . cpp \n class Instrumenter : InstrumenterBase { \n return S ; \n case StmtKind : : Brace : \n return transformBraceStmt ( cast < BraceStmt > ( S ) ) ; \n + case StmtKind : : Defer : \n + return transformDeferStmt ( cast < DeferStmt > ( S ) ) ; \n case StmtKind : : If : \n return transformIfStmt ( cast < IfStmt > ( S ) ) ; \n case StmtKind : : Guard : \n class Instrumenter : InstrumenterBase { \n } \n } \n \n + DeferStmt * transformDeferStmt ( DeferStmt * DS ) { \n + if ( auto * FD = DS - > getTempDecl ( ) ) { \n + auto Implicit = FD - > isImplicit ( ) ; \n + FD - > setImplicit ( false ) ; \n + auto * D = transformDecl ( FD ) ; \n + D - > setImplicit ( Implicit ) ; \n + assert ( D = = FD ) ; \n + } \n + return DS ; \n + } \n + \n / / transform * ( ) return their input if it ' s unmodified , \n / / or a modified copy of their input otherwise . \n IfStmt * transformIfStmt ( IfStmt * IS ) {", "msg": "[ PlaygroundTransform ] Implemented support for defer statements .\n"}
{"diff": "a / src / gui / popup_frame . cpp \n  b / src / gui / popup_frame . cpp \n bool PopupFrame : : onProcessMessage ( JMessage msg ) \n break ; \n \n case JM_KEYPRESSED : \n - if ( m_filtering & & msg - > key . scancode < KEY_MODIFIERS ) \n + if ( m_filtering & & \n + ( msg - > key . scancode = = KEY_ESC | | \n + msg - > key . scancode = = KEY_ENTER | | \n + msg - > key . scancode = = KEY_ENTER_PAD ) ) { \n closeWindow ( NULL ) ; \n - break ; \n + } \n + return false ; \n \n case JM_BUTTONPRESSED : \n / * if the user click outside the window , we have to close the", "msg": "Avoid sending keys to gui manager when a popup frame is visible .\n"}
{"diff": "a / src / init . cpp \n  b / src / init . cpp \n bool AppInit2 ( ) \n \n if ( mapArgs . count ( \" - loadblock \" ) ) \n { \n + uiInterface . InitMessage ( _ ( \" Importing blocks . . . \" ) ) ; \n BOOST_FOREACH ( string strFile , mapMultiArgs [ \" - loadblock \" ] ) \n { \n FILE * file = fopen ( strFile . c_str ( ) , \" rb \" ) ;", "msg": "add splashscreen message when importing blocks via - loadblock\n"}
{"diff": "a / Telegram / SourceFiles / dialogs / dialogs_inner_widget . cpp \n  b / Telegram / SourceFiles / dialogs / dialogs_inner_widget . cpp \n bool InnerWidget : : updateReorderPinned ( QPoint localPosition ) { \n const auto delta = [ & ] { \n if ( localPosition . y ( ) < _visibleTop ) { \n return localPosition . y ( ) - _visibleTop ; \n + } else if ( _openedFolder & & localPosition . y ( ) > _visibleBottom ) { \n + return localPosition . y ( ) - _visibleBottom ; \n } \n return 0 ; \n } ( ) ;", "msg": "In archive allow scroll - down - by - pinned - drag .\n"}
{"diff": "a / xbmc / guilib / GUIWindow . cpp \n  b / xbmc / guilib / GUIWindow . cpp \n void CGUIWindow : : AllocResources ( bool forceLoad / * = FALSE * / ) \n } \n } \n \n + # ifdef _DEBUG \n int64_t slend ; \n slend = CurrentHostCounter ( ) ; \n + # endif \n \n / / and now allocate resources \n CGUIControlGroup : : AllocResources ( ) ;", "msg": "[ GUIWindow ] Variable ' slend ' is assigned a value that is never used .\n"}
{"diff": "a / xbmc / cores / dvdplayer / DVDTSCorrection . cpp \n  b / xbmc / cores / dvdplayer / DVDTSCorrection . cpp \n double CPullupCorrection : : CalcFrameDuration ( ) \n \n double lowestdiff = DVD_TIME_BASE ; \n int selected = - 1 ; \n - for ( int i = 0 ; i < sizeof ( durations ) / sizeof ( durations [ 0 ] ) ; i + + ) \n + for ( size_t i = 0 ; i < sizeof ( durations ) / sizeof ( durations [ 0 ] ) ; i + + ) \n { \n double diff = fabs ( frameduration - durations [ i ] ) ; \n if ( diff < DVD_MSEC_TO_TIME ( 0 . 02 ) & & diff < lowestdiff )", "msg": "fixed compiler warning , signed / unsigned comparision\n"}
{"diff": "a / fdbserver / Status . actor . cpp \n  b / fdbserver / Status . actor . cpp \n ACTOR Future < Optional < Value > > getActivePrimaryDC ( Database cx ) { \n \n loop { \n try { \n - tr . setOption ( FDBTransactionOptions : : ACCESS_SYSTEM_KEYS ) ; \n + tr . setOption ( FDBTransactionOptions : : READ_SYSTEM_KEYS ) ; \n Optional < Value > res = wait ( tr . get ( primaryDatacenterKey ) ) ; \n return res ; \n } catch ( Error & e ) {", "msg": "Update fdbserver / Status . actor . cpp\n"}
{"diff": "a / xbmc / cores / dvdplayer / DVDCodecs / Video / VDPAU . cpp \n  b / xbmc / cores / dvdplayer / DVDCodecs / Video / VDPAU . cpp \n int CVDPAU : : ConfigVDPAU ( AVCodecContext * avctx , int ref_frames ) \n totalAvailableOutputSurfaces , \n tmpMaxOutputSurfaces , \n NUM_OUTPUT_SURFACES ) ; \n - assert ( totalAvailableOutputSurfaces > 0 ) ; \n \n surfaceNum = presentSurfaceNum = 0 ; \n outputSurface = outputSurfaces [ surfaceNum ] ;", "msg": "remove assertion to allow recovery attempt if vdp_output_surface_create fails\n"}
{"diff": "a / xbmc / Application . cpp \n  b / xbmc / Application . cpp \n bool CApplication : : OnMessage ( CGUIMessage & message ) \n case GUI_MSG_PLAYLISTPLAYER_STOPPED : \n m_itemCurrentFile - > Reset ( ) ; \n CServiceBroker : : GetGUI ( ) - > GetInfoManager ( ) . ResetCurrentItem ( ) ; \n + if ( m_appPlayer . IsPlaying ( ) ) \n + StopPlaying ( ) ; \n PlaybackCleanup ( ) ; \n return true ;", "msg": "Stop playing current file when playlist player has stopped .\n"}
{"diff": "a / editor / editor_node . cpp \n  b / editor / editor_node . cpp \n EditorNode : : EditorNode ( ) { \n bottom_panel - > add_child ( bottom_panel_vb ) ; \n \n bottom_panel_hb = memnew ( HBoxContainer ) ; \n + bottom_panel_hb - > set_custom_minimum_size ( Size2 ( 0 , 24 ) ) ; / / Adjust for the height of the \" Expand Bottom Dock \" icon . \n bottom_panel_vb - > add_child ( bottom_panel_hb ) ; \n \n bottom_panel_hb_editors = memnew ( HBoxContainer ) ;", "msg": "Adjust bottom panel ' s minimal height for the expand icon\n"}
{"diff": "a / xbmc / filesystem / CurlFile . cpp \n  b / xbmc / filesystem / CurlFile . cpp \n bool CCurlFile : : Download ( const std : : string & strURL , const std : : string & strFileNa \n / / Detect whether we are \" online \" or not ! Very simple and dirty ! \n bool CCurlFile : : IsInternet ( ) \n { \n - CURL url ( \" http : / / www . google . com \" ) ; \n + CURL url ( \" http : / / www . msftncsi . com / ncsi . txt \" ) ; \n bool found = Exists ( url ) ; \n + if ( ! found ) \n + { \n + / / fallback \n + Close ( ) ; \n + url . Parse ( \" http : / / www . w3 . org / \" ) ; \n + found = Exists ( url ) ; \n + } \n Close ( ) ; \n \n return found ;", "msg": "ADD : add a fallback site for internet detection\n"}
{"diff": "a / xbmc / music / windows / GUIWindowMusicNav . cpp \n  b / xbmc / music / windows / GUIWindowMusicNav . cpp \n bool CGUIWindowMusicNav : : Update ( const std : : string & strDirectory , bool updateFilt \n \n if ( CGUIWindowMusicBase : : Update ( strDirectory , updateFilterPath ) ) \n { \n + if ( m_vecItems - > GetContent ( ) . empty ( ) ) \n + m_vecItems - > SetContent ( \" files \" ) ; \n + \n m_thumbLoader . Load ( * m_unfilteredItems ) ; \n return true ; \n }", "msg": "changed : integrate custom : : Update code from songs in to Nav\n"}
{"diff": "a / xbmc / music / MusicDatabase . cpp \n  b / xbmc / music / MusicDatabase . cpp \n bool CMusicDatabase : : GetAlbumsByYear ( const CStdString & strBaseDir , CFileItemList \n return false ; \n \n musicUrl . AddOption ( \" year \" , year ) ; \n - musicUrl . AddOption ( \" singles \" , true ) ; / / allow singles to be listed \n + musicUrl . AddOption ( \" show_singles \" , true ) ; / / allow singles to be listed \n \n Filter filter ; \n return GetAlbumsByWhere ( musicUrl . ToString ( ) , filter , items ) ; \n bool CMusicDatabase : : GetFilter ( CDbUrl & musicUrl , Filter & filter , SortDescription \n / / no artist given , so exclude any single albums ( aka empty tagged albums ) \n else \n { \n - option = options . find ( \" singles \" ) ; \n + option = options . find ( \" show_singles \" ) ; \n if ( option = = options . end ( ) | | ! option - > second . asBoolean ( ) ) \n filter . AppendWhere ( \" albumview . strAlbum < > ' ' \" ) ; \n }", "msg": "musicdb : fix conflicting \" singles \" filter option introduced by 9fbf13eded5d682d4ae210043e536895c9356c18 ( fixes )\n"}
{"diff": "a / Source / Readers / ReaderLib / ReaderShim . cpp \n  b / Source / Readers / ReaderLib / ReaderShim . cpp \n void ReaderShim < ElemType > : : StartDistributedMinibatchLoop ( \n m_reader - > StartEpoch ( config ) ; \n m_endOfEpoch = false ; \n \n + / / For adaptive minibatch , make sure there are no outstanding reads . \n + if ( m_prefetchTask . valid ( ) ) \n + { \n + m_prefetchTask . wait ( ) ; \n + } \n + \n m_prefetchTask = std : : async ( m_launchType , [ this ] ( ) \n { \n return m_reader - > ReadMinibatch ( ) ;", "msg": "ReaderLib / ReaderShim . cpp : wait for outstanding prefetch when epoch started\n"}
{"diff": "a / scene / register_scene_types . cpp \n  b / scene / register_scene_types . cpp \n void register_scene_types ( ) { \n ClassDB : : register_class < QuadMesh > ( ) ; \n ClassDB : : register_virtual_class < Material > ( ) ; \n ClassDB : : register_class < SpatialMaterial > ( ) ; \n + ClassDB : : add_compatibility_class ( \" FixedSpatialMaterial \" , \" SpatialMaterial \" ) ; \n SceneTree : : add_idle_callback ( SpatialMaterial : : flush_changes ) ; \n SpatialMaterial : : init_shaders ( ) ;", "msg": "Add compatibility class for FixedSpatialMaterial\n"}
{"diff": "a / hphp / runtime / vm / jit / print . cpp \n  b / hphp / runtime / vm / jit / print . cpp \n void print ( std : : ostream & os , const Block * block , \n } \n \n os < < std : : string ( kIndent - 2 , ' ' ) ; \n - if ( auto next = block - > next ( ) ) { \n + auto next = block - > empty ( ) ? nullptr : block - > next ( ) ; \n + if ( next ) { \n os < < punc ( \" - > \" ) ; \n printLabel ( os , next ) ; \n os < < ' \\ n ' ;", "msg": "Avoid assertion failure while trying to print an empty block\n"}
{"diff": "a / src / mongo / db / projection . cpp \n  b / src / mongo / db / projection . cpp \n namespace mongo { \n \n / / initialize new Matcher object ( s ) \n \n - _matchers . insert ( make_pair ( mongoutils : : str : : before ( e . fieldName ( ) , ' . ' ) , \n - new Matcher ( e . wrap ( ) , true ) ) ) ; \n + _matchers . insert ( make_pair ( \n + mongoutils : : str : : before ( e . fieldName ( ) , ' . ' ) , \n + shared_ptr < Matcher > ( new Matcher ( e . wrap ( ) , true ) ) ) ) ; \n add ( e . fieldName ( ) , true ) ; \n } \n else {", "msg": "Be more explicit about types when constructing pair for insert\n"}
{"diff": "a / src / misc_utilities / calibrate . cpp \n  b / src / misc_utilities / calibrate . cpp \n int main ( int argc , char * * argv ) { \n if ( c = = ' o ' ) \n { \n cout < < \" prewarp = \" < < get_config ( ) < < endl ; \n - \n + } else if ( c = = ' q ' ) \n + { \n + cout < < \" prewarp = \" < < get_config ( ) < < endl ; \n + break ; \n } \n }", "msg": "When pressing keyboard key ' q ' , output prewarp configuration and exit program .\n"}
{"diff": "a / lib / SIL / SILVerifier . cpp \n  b / lib / SIL / SILVerifier . cpp \n void SILModule : : verify ( ) const { \n } \n } \n \n - # ifndef NDEBUG \n / / / Determine whether an instruction may not have a SILDebugScope . \n bool swift : : maybeScopeless ( SILInstruction & I ) { \n if ( I . getFunction ( ) - > isBare ( ) ) \n return true ; \n return ! isa < DebugValueInst > ( I ) & & ! isa < DebugValueAddrInst > ( I ) ; \n } \n - # endif", "msg": "Remove conditional compilation from maybeScopeless , because SILVerifier is not conditionally compiled anymore\n"}
{"diff": "a / lib / SILGen / SILGenType . cpp \n  b / lib / SILGen / SILGenType . cpp \n \n # include \" swift / AST / TypeMemberVisitor . h \" \n # include \" swift / Basic / Fallthrough . h \" \n # include \" swift / SIL / SILArgument . h \" \n - # include \" swift / SIL / SILWitnessVisitor . h \" \n # include \" swift / SIL / TypeLowering . h \" \n \n using namespace swift ;", "msg": "SILGen : Remove unused include , NFC\n"}
{"diff": "a / lib / Driver / Tools . cpp \n  b / lib / Driver / Tools . cpp \n static void addCommonFrontendArgs ( const ToolChain & TC , \n / / Pass through the values passed to - Xfrontend . \n inputArgs . AddAllArgValues ( arguments , options : : OPT_Xfrontend ) ; \n \n - / / Pass through any - Xllvm flags . \n + / / Pass through any subsystem flags . \n inputArgs . AddAllArgs ( arguments , options : : OPT_Xllvm ) ; \n + inputArgs . AddAllArgs ( arguments , options : : OPT_Xcc ) ; \n \n const std : : string & moduleDocOutputPath = \n output - > getAdditionalOutputForType ( types : : TY_SwiftModuleDocFile ) ;", "msg": "[ driver ] Pass - Xcc options down to frontend tools .\n"}
{"diff": "diff - - git a / Stack Using Array . cpp b / Stack Using Array . cpp \n  a / Stack Using Array . cpp \n  b / Stack Using Array . cpp \n void show ( ) \n } \n } \n \n + void topmost ( ) \n + { \n + cout < < \" \\ nTopmost element : \" < < stack [ top - 1 ] ; \n + } \n int main ( ) \n { \n int ch , x ; \n int main ( ) \n cout < < \" \\ n1 . Push \" ; \n cout < < \" \\ n2 . Pop \" ; \n cout < < \" \\ n3 . Print \" ; \n - cout < < \" \\ nEnter Your Choice : \" ; \n + cout < < \" \\ n4 . Print topmost element : \" ; \n + cout < < \" \\ nEnter Your Choice : \" ; \n cin > > ch ; \n if ( ch = = 1 ) \n { \n int main ( ) \n { \n show ( ) ; \n } \n + else if ( ch = = 4 ) \n + { \n + topmost ( ) ; \n + } \n } \n while ( ch ! = 0 ) ;", "msg": "Made changes to stack program using array implementation\n"}
{"diff": "a / dbtests / dbtests . cpp \n  b / dbtests / dbtests . cpp \n int main ( int argc , char * * argv ) { \n tests . add ( jsobjTests ( ) , \" jsobj \" ) ; \n tests . add ( jsonTests ( ) , \" json \" ) ; \n tests . add ( matcherTests ( ) , \" matcher \" ) ; \n - tests . add ( namespaceTests ( ) , \" namespace \" ) ; \n + / / tests . add ( namespaceTests ( ) , \" namespace \" ) ; \n tests . add ( pairingTests ( ) , \" pairing \" ) ; \n - tests . add ( pdfileTests ( ) , \" pdfile \" ) ; \n + / / tests . add ( pdfileTests ( ) , \" pdfile \" ) ; \n tests . add ( queryTests ( ) , \" query \" ) ; \n tests . add ( replTests ( ) , \" repl \" ) ; \n tests . add ( sockTests ( ) , \" sock \" ) ;", "msg": "Disable tests until I can fix the failures tomorrow\n"}
{"diff": "a / arangod / Aql / ExecutionPlan . cpp \n  b / arangod / Aql / ExecutionPlan . cpp \n struct NodeRemover : public WalkerWorker < ExecutionNode > { \n } \n \n void after ( ExecutionNode * en ) { \n - _plan - > unregisterNode ( en ) ; \n parents . pop_back ( ) ; \n } \n } ;", "msg": "do not unregister nodes on unlink\n"}
{"diff": "a / lib / IRGen / GenDecl . cpp \n  b / lib / IRGen / GenDecl . cpp \n void IRGenModule : : emitGlobalLists ( ) { \n ExistingLLVMUsed - > eraseFromParent ( ) ; \n } \n \n - assert ( std : : all_of ( LLVMUsed . begin ( ) , LLVMUsed . end ( ) , \n - [ ] ( const llvm : : WeakVH & global ) { \n - return ! isa < llvm : : GlobalValue > ( global ) | | \n - ! cast < llvm : : GlobalValue > ( global ) - > isDeclaration ( ) ; \n - } ) & & \" all globals in the ' used ' list must be definitions \" ) ; \n + std : : for_each ( LLVMUsed . begin ( ) , LLVMUsed . end ( ) , \n + [ ] ( const llvm : : WeakVH & global ) { \n + assert ( ! isa < llvm : : GlobalValue > ( global ) | | \n + ! cast < llvm : : GlobalValue > ( global ) - > isDeclaration ( ) & & \n + \" all globals in the ' used ' list must be definitions \" ) ; \n + } ) ; \n emitGlobalList ( * this , LLVMUsed , \" llvm . used \" , \" llvm . metadata \" , \n llvm : : GlobalValue : : AppendingLinkage , \n Int8PtrTy ,", "msg": "IRGen : Improve an assertion for easier debugging\n"}
{"diff": "a / s / strategy_shard . cpp \n  b / s / strategy_shard . cpp \n namespace mongo { \n \n ShardInfo * info = r . getShardInfo ( ) ; \n assert ( info ) ; \n + \n + Query query ( q . query ) ; \n \n vector < Shard * > shards ; \n - if ( info - > getShardsForQuery ( shards , q . query ) = = 1 ) { \n + if ( info - > getShardsForQuery ( shards , query . getFilter ( ) ) = = 1 ) { \n doQuery ( r , shards [ 0 ] - > getServer ( ) ) ; \n return ; \n } \n \n + \n throw UserException ( \" real sharding doesn ' t nwork \" ) ; \n }", "msg": "only make decision on shards based on filter\n"}
{"diff": "a / src / PreferencesDialog . cpp \n  b / src / PreferencesDialog . cpp \n QVariant PreferencesDialog : : getSettingsDefaultValue ( const QString & group , const \n { \n QFont font ( \" Monospace \" ) ; \n font . setStyleHint ( QFont : : TypeWriter ) ; \n - return font . family ( ) ; \n + return QFontInfo ( font ) . family ( ) ; \n } \n \n / / editor / fontsize or log / fontsize ?", "msg": "Use QFontInfo so Windows chooses a correct font\n"}
{"diff": "a / scripting / javascript / bindings / jsb_websocket . cpp \n  b / scripting / javascript / bindings / jsb_websocket . cpp \n JSBool js_cocos2dx_extension_WebSocket_constructor ( JSContext * cx , uint32_t argc , \n JSB_WebSocketDelegate * delegate = new JSB_WebSocketDelegate ( ) ; \n delegate - > setJSDelegate ( obj ) ; \n \n - if ( argc = = 2 ) \n + if ( argc = = 2 & & ! JSVAL_IS_VOID ( argv [ 1 ] ) ) \n { \n std : : vector < std : : string > protocols ;", "msg": "undefined argument should not be counted as a valid argument\n"}
{"diff": "a / src / app / doc_exporter . cpp \n  b / src / app / doc_exporter . cpp \n class DocExporter : : BestFitLayoutSamples : \n public DocExporter : : LayoutSamples { \n public : \n void layoutSamples ( Samples & samples , int borderPadding , int shapePadding , int & width , int & height ) override { \n - gfx : : PackingRects pr ; \n - \n - / / TODO Add support for shape paddings \n + gfx : : PackingRects pr ( borderPadding , shapePadding ) ; \n \n for ( auto & sample : samples ) { \n if ( sample . isDuplicated ( ) | |", "msg": "Add padding support for - - sheet - pack\n"}
{"diff": "a / fdbrpc / crc32c . cpp \n  b / fdbrpc / crc32c . cpp \n static inline uint32_t shift_crc ( uint32_t shift_table [ ] [ 256 ] , uint32_t crc ) \n } \n \n / * Compute CRC - 32C using the Intel hardware instruction . * / \n - # ifndef _WIN32 \n + # if defined ( __clang__ ) | | defined ( __GNUG__ ) \n __attribute__ ( ( target ( \" sse4 . 2 \" ) ) ) \n # endif \n static uint32_t append_hw ( uint32_t crc , const uint8_t * buf , size_t len )", "msg": "Explicitly check for clang and g + +\n"}
{"diff": "a / lib / ClangImporter / ClangImporter . cpp \n  b / lib / ClangImporter / ClangImporter . cpp \n static bool shouldIgnoreMacro ( const clang : : IdentifierInfo * identifier , \n \n / / Currently we only convert non - function - like macros . \n if ( macro - > isFunctionLike ( ) ) \n - return false ; \n + return true ; \n \n / / Consult the blacklist of macros to suppress . \n auto suppressMacro =", "msg": "[ Clang importer ] Function - like macros are ignored .\n"}
{"diff": "a / Telegram / SourceFiles / history / view / media / history_view_poll . cpp \n  b / Telegram / SourceFiles / history / view / media / history_view_poll . cpp \n void Poll : : paintFilling ( \n \n if ( chosen & & ! correct ) { \n p . setBrush ( st : : boxTextFgError ) ; \n + } else if ( chosen & & correct & & _poll - > quiz ( ) & & ! outbg ) { \n + p . setBrush ( st : : boxTextFgGood ) ; \n } else { \n const auto bar = outbg ? ( selected ? st : : msgWaveformOutActiveSelected : st : : msgWaveformOutActive ) : ( selected ? st : : msgWaveformInActiveSelected : st : : msgWaveformInActive ) ; \n p . setBrush ( bar ) ;", "msg": "Show correct incoming quiz votes in green .\n"}
{"diff": "a / src / treelearner / voting_parallel_tree_learner . cpp \n  b / src / treelearner / voting_parallel_tree_learner . cpp \n void VotingParallelTreeLearner < TREELEARNER_T > : : GlobalVoting ( int leaf_idx , const \n / / get top k \n std : : vector < LightSplitInfo > top_k_splits ; \n ArrayArgs < LightSplitInfo > : : MaxK ( feature_best_split , top_k_ , & top_k_splits ) ; \n - std : : sort ( top_k_splits . begin ( ) , top_k_splits . end ( ) , std : : greater < LightSplitInfo > ( ) ) ; \n + std : : stable_sort ( top_k_splits . begin ( ) , top_k_splits . end ( ) , std : : greater < LightSplitInfo > ( ) ) ; \n for ( auto & split : top_k_splits ) { \n if ( split . gain = = kMinScore | | split . feature = = - 1 ) { \n continue ;", "msg": "use stable_sort for splits ( )\n"}
{"diff": "a / lib / SILGen / SILGenType . cpp \n  b / lib / SILGen / SILGenType . cpp \n class SILGenConformance : public SILGenWitnessTable < SILGenConformance > { \n if ( witnessSerialized & & \n fixmeWitnessHasLinkageThatNeedsToBePublic ( witnessLinkage ) ) { \n witnessLinkage = SILLinkage : : Public ; \n - witnessSerialized = IsNotSerialized ; \n + witnessSerialized = ( SGM . M . getOptions ( ) . SILSerializeWitnessTables \n + ? IsSerialized \n + : IsNotSerialized ) ; \n } else { \n / / This is the \" real \" rule ; the above case should go away once we \n / / figure out what ' s going on .", "msg": "Serialize witnesses if - sil - serialize - witness - tables is provided\n"}
{"diff": "a / drivers / gles2 / rasterizer_scene_gles2 . cpp \n  b / drivers / gles2 / rasterizer_scene_gles2 . cpp \n void RasterizerSceneGLES2 : : render_scene ( const Transform & p_cam_transform , const \n } break ; \n \n default : { \n - print_line ( \" uhm \" ) ; \n + / / FIXME : implement other background modes \n } break ; \n } \n }", "msg": "Reduce verbosity for unsupported GLES2 bg modes\n"}
{"diff": "a / src / util / system . cpp \n  b / src / util / system . cpp \n void AllocateFileRange ( FILE * file , unsigned int offset , unsigned int length ) { \n fcntl ( fileno ( file ) , F_PREALLOCATE , & fst ) ; \n } \n ftruncate ( fileno ( file ) , fst . fst_length ) ; \n - # elif defined ( __linux__ ) \n + # else \n + # if defined ( __linux__ ) \n / / Version using posix_fallocate \n off_t nEndPos = ( off_t ) offset + length ; \n - posix_fallocate ( fileno ( file ) , 0 , nEndPos ) ; \n - # else \n + if ( 0 = = posix_fallocate ( fileno ( file ) , 0 , nEndPos ) ) return ; \n + # endif \n / / Fallback version \n / / TODO : just write one byte per block \n static const char buf [ 65536 ] = { } ;", "msg": "Handle the result of posix_fallocate system call\n"}
{"diff": "a / PowerEditor / src / NppIO . cpp \n  b / PowerEditor / src / NppIO . cpp \n bool Notepad_plus : : loadSession ( Session & session , bool isSnapshotMode ) \n } \n buf - > setLangType ( typeToSet , pLn ) ; \n buf - > setEncoding ( session . _subViewFiles [ k ] . _encoding ) ; \n - buf - > setUserReadOnly ( session . _mainViewFiles [ k ] . _isUserReadOnly ) ; \n + buf - > setUserReadOnly ( session . _subViewFiles [ k ] . _isUserReadOnly ) ; \n \n if ( isSnapshotMode & & session . _subViewFiles [ k ] . _backupFilePath ! = TEXT ( \" \" ) & & PathFileExists ( session . _subViewFiles [ k ] . _backupFilePath . c_str ( ) ) ) \n buf - > setDirty ( true ) ;", "msg": "Fix a crash issue due to cfa702a8a87272c276e4cb46c8979f2418ef25e2\n"}
{"diff": "a / lib / SIL / SILValueProjection . cpp \n  b / lib / SIL / SILValueProjection . cpp \n bool LSLocation : : isNonEscapingLocalLSLocation ( SILFunction * Fn , \n / / An alloc_stack is definitely dead at the end of the function . \n if ( isa < AllocStackInst > ( Base ) ) \n return true ; \n + / / For other allocations we ask escape analysis . \n + auto * ConGraph = EA - > getConnectionGraph ( Fn ) ; \n + if ( isa < AllocationInst > ( Base ) ) { \n + auto * Node = ConGraph - > getNodeOrNull ( Base , EA ) ; \n + if ( Node & & ! Node - > escapes ( ) ) { \n + return true ; \n + } \n + } \n return false ; \n }", "msg": "After looking at the commit at which the test case broke . I do not think the\n"}
{"diff": "a / scene / gui / text_edit . cpp \n  b / scene / gui / text_edit . cpp \n void TextEdit : : _update_scrollbars ( ) { \n \n int hscroll_rows = ( ( hmin . height - 1 ) / get_row_height ( ) ) + 1 ; \n int visible_rows = get_visible_rows ( ) ; \n - int total_rows = text . size ( ) * cache . line_spacing ; \n + int total_rows = text . size ( ) ; \n \n int vscroll_pixels = v_scroll - > get_combined_minimum_size ( ) . width ; \n int visible_width = size . width - cache . style_normal - > get_minimum_size ( ) . width ;", "msg": "Total rows of text edit was calculated wrong , fixed issue\n"}
{"diff": "a / dbms / src / Storages / StorageMergeTree . cpp \n  b / dbms / src / Storages / StorageMergeTree . cpp \n void StorageMergeTree : : alter ( \n if ( primary_key_is_modified & & data . merging_params . mode = = MergeTreeData : : MergingParams : : Unsorted ) \n throw Exception ( \" UnsortedMergeTree cannot have primary key \" , ErrorCodes : : BAD_ARGUMENTS ) ; \n \n + if ( primary_key_is_modified & & supportsSampling ( ) ) \n + throw Exception ( \" MODIFY PRIMARY KEY only supported for tables without sampling key \" , ErrorCodes : : BAD_ARGUMENTS ) ; \n + \n MergeTreeData : : DataParts parts = data . getAllDataParts ( ) ; \n for ( const MergeTreeData : : DataPartPtr & part : parts ) \n if ( auto transaction = data . alterDataPart ( part , columns_for_parts , new_primary_key_ast , false ) )", "msg": "Added check [ # METR - 22325 ] .\n"}
{"diff": "a / unittests / api_tests . cpp \n  b / unittests / api_tests . cpp \n BOOST_FIXTURE_TEST_CASE ( deferred_transaction_tests , TESTER ) { try { \n / / schedule \n { \n transaction_trace_ptr trace ; \n - control - > applied_transaction . connect ( [ & ] ( const transaction_trace_ptr & t ) { if ( t - > scheduled ) { trace = t ; } } ) ; \n + auto c = control - > applied_transaction . connect ( [ & ] ( const transaction_trace_ptr & t ) { if ( t - > scheduled ) { trace = t ; } } ) ; \n CALL_TEST_FUNCTION ( * this , \" test_transaction \" , \" send_deferred_transaction \" , { } ) ; \n / / check that it doesn ' t get executed immediately \n control - > push_next_scheduled_transaction ( ) ; \n BOOST_FIXTURE_TEST_CASE ( deferred_transaction_tests , TESTER ) { try { \n / / confirm printed message \n BOOST_TEST ( ! trace - > action_traces . empty ( ) ) ; \n BOOST_TEST ( trace - > action_traces . back ( ) . console = = \" deferred executed \\ n \" ) ; \n + c . disconnect ( ) ; \n } \n \n produce_blocks ( 10 ) ;", "msg": "Remove callback to prevent accessing no longer existing stack objects .\n"}
{"diff": "a / libraries / chain / controller . cpp \n  b / libraries / chain / controller . cpp \n struct controller_impl { \n bool trust = ! conf . force_all_checks & & ( s = = controller : : block_status : : irreversible | | s = = controller : : block_status : : validated ) ; \n auto new_header_state = fork_db . add ( b , trust ) ; \n emit ( self . accepted_block_header , new_header_state ) ; \n - / / on replay irreversible is not emitted by fork database , so emit it explicitly here \n - if ( s = = controller : : block_status : : irreversible ) \n - emit ( self . irreversible_block , new_header_state ) ; \n \n if ( read_mode ! = db_read_mode : : IRREVERSIBLE ) { \n maybe_switch_forks ( s ) ; \n } \n + \n + / / on replay irreversible is not emitted by fork database , so emit it explicitly here \n + if ( s = = controller : : block_status : : irreversible ) \n + emit ( self . irreversible_block , new_header_state ) ; \n + \n } FC_LOG_AND_RETHROW ( ) \n }", "msg": "avoid plugin through irreversible_block signal change block , so that apply_block faild . andkeep signal according to the order of accepted_transaction , applied_transaction and irreversible_block .\n"}
{"diff": "a / editor / project_settings_editor . cpp \n  b / editor / project_settings_editor . cpp \n ProjectSettingsEditor : : ProjectSettingsEditor ( EditorData * p_data ) { \n restart_icon - > set_v_size_flags ( Control : : SIZE_SHRINK_CENTER ) ; \n restart_hb - > add_child ( restart_icon ) ; \n restart_label = memnew ( Label ) ; \n - restart_label - > set_text ( TTR ( \" The editor must be restarted for changes to take effect . \" ) ) ; \n + restart_label - > set_text ( TTR ( \" Changed settings will be applied to the editor after restarting . \" ) ) ; \n restart_hb - > add_child ( restart_label ) ; \n restart_hb - > add_spacer ( ) ; \n Button * restart_button = memnew ( Button ) ;", "msg": "Project Settings ' restart ' message put focus on editor rather than project itself\n"}
{"diff": "a / Code / CryEngine / RenderDll / XRenderD3D9 / PipelineProfiler . cpp \n  b / Code / CryEngine / RenderDll / XRenderD3D9 / PipelineProfiler . cpp \n CRenderPipelineProfiler : : CRenderPipelineProfiler ( ) \n \n m_avgFrameTime = 0 ; \n m_enabled = false ; \n + m_paused = false ; \n m_recordData = false ; \n \n m_stack . reserve ( 8 ) ;", "msg": "! B ( Renderer ) Prevent pipeline - profiler to indefinitely pause when splash - screen doesn ' t happen\n"}
{"diff": "a / xbmc / listproviders / DirectoryProvider . cpp \n  b / xbmc / listproviders / DirectoryProvider . cpp \n \n # include \" settings / Settings . h \" \n # include \" threads / SingleLock . h \" \n # include \" utils / JobManager . h \" \n + # include \" utils / log . h \" \n # include \" utils / SortUtils . h \" \n # include \" utils / URIUtils . h \" \n # include \" utils / Variant . h \" \n bool CDirectoryProvider : : Update ( bool forceRefresh ) \n fireJob | = UpdateSort ( ) ; \n fireJob | = UpdateLimit ( ) ; \n if ( fireJob ) \n + { \n + { \n + CSingleLock lock ( m_section ) ; \n + CLog : : Log ( LOGDEBUG , \" CDirectoryProvider [ % s ] : refreshing . . \" , m_currentUrl . c_str ( ) ) ; \n + } \n FireJob ( ) ; \n + } \n \n for ( std : : vector < CGUIStaticItemPtr > : : iterator i = m_items . begin ( ) ; i ! = m_items . end ( ) ; + + i ) \n changed | = ( * i ) - > UpdateVisibility ( m_parentID ) ;", "msg": "[ listprovider ] add trace logging for refresh\n"}
{"diff": "a / imgui . cpp \n  b / imgui . cpp \n ImVec2 ImGui : : GetCursorPos ( ) \n \n float ImGui : : GetCursorPosX ( ) \n { \n - ImGuiWindow * window = GetCurrentWindow ( ) ; \n + ImGuiWindow * window = GetCurrentWindowRead ( ) ; \n return window - > DC . CursorPos . x - window - > Pos . x + window - > Scroll . x ; \n } \n \n float ImGui : : GetCursorPosY ( ) \n { \n - ImGuiWindow * window = GetCurrentWindow ( ) ; \n + ImGuiWindow * window = GetCurrentWindowRead ( ) ; \n return window - > DC . CursorPos . y - window - > Pos . y + window - > Scroll . y ; \n }", "msg": "Using GetCurrentWindowRead ( ) instead of GetCurrentWindow ( )\n"}
{"diff": "a / lib / Sema / TypeCheckDecl . cpp \n  b / lib / Sema / TypeCheckDecl . cpp \n class DeclChecker : public DeclVisitor < DeclChecker > { \n Expr * initializer = nullptr ; \n if ( isPatternProperty ( PBD - > getPattern ( ) ) ) { \n / / Properties don ' t have initializers . \n - } else if ( TC . Context . LangOpts . UseDefiniteInit ) { \n + } else if ( TC . Context . LangOpts . UseDefiniteInit & & \n + ! isa < TopLevelCodeDecl > ( PBD - > getDeclContext ( ) ) ) { \n / / If we are using the new definite initialization rules , we don ' t \n - / / default initialize anything ! \n + / / default initialize local variables , only globals . \n } else if ( ! TC . isDefaultInitializable ( ty , & initializer ) ) { \n / / FIXME : Better diagnostics here . \n TC . diagnose ( PBD , diag : : decl_no_default_init , ty ) ;", "msg": "Global variables must have an initializer or be default constructible , even\n"}
{"diff": "a / torch / csrc / toffee / export . cpp \n  b / torch / csrc / toffee / export . cpp \n std : : string ExportGraph ( std : : unique_ptr < Graph > & g ) { \n } \n if ( node - > type ( ) - > kind ( ) = = TypeKind : : MultiType ) { \n for ( auto u : node - > uses ( ) ) { \n + JIT_ASSERT ( u . user - > kind ( ) = = kSelect ) ; \n + / / Python operators whose backwards are not traceable will have \n + / / handle outputs ; at the moment ToffeeIR export only supports \n + / / forwards only , so these will be unused \n + if ( u . user - > type ( ) - > kind ( ) = = TypeKind : : HandleType ) { \n + JIT_ASSERT ( u . user - > uses ( ) . empty ( ) ) ; \n + continue ; \n + } \n p_n - > add_output ( node_name ( u . user ) ) ; \n } \n } else {", "msg": "Ignore Handle when exporting to ToffeeIR .\n"}
{"diff": "a / Code / CryPlugins / CrySensorSystem / Module / SchematycEntitySensorVolumeComponent . cpp \n  b / Code / CryPlugins / CrySensorSystem / Module / SchematycEntitySensorVolumeComponent . cpp \n void CSchematycEntitySensorVolumeComponent : : OnSensorEvent ( const SSensorEvent & ev \n { \n case ESensorEventType : : Entering : \n { \n - GetEntity ( ) - > GetSchematycObject ( ) - > ProcessSignal ( SEnteringSignal ( otherVolumeParams . entityId ) ) ; \n + GetEntity ( ) - > GetSchematycObject ( ) - > ProcessSignal ( SEnteringSignal ( otherVolumeParams . entityId ) , GetGUID ( ) ) ; \n break ; \n } \n case ESensorEventType : : Leaving : \n { \n - GetEntity ( ) - > GetSchematycObject ( ) - > ProcessSignal ( SLeavingSignal ( otherVolumeParams . entityId ) ) ; \n + GetEntity ( ) - > GetSchematycObject ( ) - > ProcessSignal ( SLeavingSignal ( otherVolumeParams . entityId ) , GetGUID ( ) ) ; \n break ; \n } \n }", "msg": "! XB ( CE - 12954 ) ( CrySensorSystem ) Fixed sensor component event processing .\n"}
{"diff": "a / xbmc / pvr / guilib / guiinfo / PVRGUIInfo . cpp \n  b / xbmc / pvr / guilib / guiinfo / PVRGUIInfo . cpp \n bool CPVRGUIInfo : : GetListItemAndPlayerLabel ( const CFileItem * item , const CGUIInf \n case LISTITEM_PREMIERED : \n if ( recording - > FirstAired ( ) . IsValid ( ) ) \n { \n - strValue = recording - > FirstAired ( ) . GetAsLocalizedDate ( true ) ; \n + strValue = recording - > FirstAired ( ) . GetAsLocalizedDate ( ) ; \n return true ; \n } \n else if ( recording - > HasYear ( ) ) \n bool CPVRGUIInfo : : GetListItemAndPlayerLabel ( const CFileItem * item , const CGUIInf \n case LISTITEM_PREMIERED : \n if ( epgTag - > FirstAired ( ) . IsValid ( ) ) \n { \n - strValue = epgTag - > FirstAired ( ) . GetAsLocalizedDate ( true ) ; \n + strValue = epgTag - > FirstAired ( ) . GetAsLocalizedDate ( ) ; \n return true ; \n } \n else if ( epgTag - > Year ( ) > 0 )", "msg": "[ PVR ] Fix date format for ListItem . Premiered and VideoPlayer . Premiered guiinfo labels .\n"}
{"diff": "a / src / core / hle / kernel / svc . cpp \n  b / src / core / hle / kernel / svc . cpp \n static ResultCode CreateThread ( Handle * out_handle , VAddr entry_point , u64 arg , V \n } \n \n if ( priority > THREADPRIO_LOWEST ) { \n - LOG_ERROR ( Kernel_SVC , \" An invalid priority was specified , expected { } but got { } \" , \n - THREADPRIO_LOWEST , priority ) ; \n + LOG_ERROR ( Kernel_SVC , \n + \" Invalid thread priority specified ( { } ) . Must be within the range 0 - 64 \" , \n + priority ) ; \n return ERR_INVALID_THREAD_PRIORITY ; \n }", "msg": "kernel / svc : Correct misleading error message within CreateThread ( )\n"}
{"diff": "a / xbmc / settings / SettingsManager . cpp \n  b / xbmc / settings / SettingsManager . cpp \n void CSettingsManager : : RegisterSettingsHandler ( ISettingsHandler * settingsHandler \n return ; \n \n CExclusiveLock lock ( m_critical ) ; \n - if ( find ( m_settingsHandlers . begin ( ) , m_settingsHandlers . end ( ) , settingsHandler ) > = m_settingsHandlers . end ( ) ) \n + if ( find ( m_settingsHandlers . begin ( ) , m_settingsHandlers . end ( ) , settingsHandler ) = = m_settingsHandlers . end ( ) ) \n m_settingsHandlers . push_back ( settingsHandler ) ; \n }", "msg": "settings : cosmetic on iterator comparison\n"}
{"diff": "a / s / commands_public . cpp \n  b / s / commands_public . cpp \n namespace mongo { \n / / so we allocate them in our thread \n / / and hand off \n \n - list < shared_ptr < ShardConnection > > shardConns ; \n + vector < shared_ptr < ShardConnection > > shardConns ; \n \n list < shared_ptr < Future : : CommandResult > > futures ; \n \n for ( set < Shard > : : iterator i = shards . begin ( ) , end = shards . end ( ) ; i ! = end ; i + + ) { \n shared_ptr < ShardConnection > temp ( new ShardConnection ( i - > getConnString ( ) , fullns ) ) ; \n + assert ( temp - > get ( ) ) ; \n futures . push_back ( Future : : spawnCommand ( i - > getConnString ( ) , dbName , shardedCommand , temp - > get ( ) ) ) ; \n shardConns . push_back ( temp ) ; \n } \n namespace mongo { \n } \n shardresults . append ( res - > getServer ( ) , res - > result ( ) ) ; \n } \n - \n + \n + for ( unsigned i = 0 ; i < shardConns . size ( ) ; i + + ) \n + shardConns [ i ] - > done ( ) ; \n + \n if ( failed ) \n return 0 ;", "msg": "release ShardConnection when done in sharded / mr\n"}
{"diff": "a / folly / test / AtomicHashArrayTest . cpp \n  b / folly / test / AtomicHashArrayTest . cpp \n class MmapAllocator { \n \n T * allocate ( size_t n ) { \n void * p = mmap ( nullptr , n * sizeof ( T ) , PROT_READ | PROT_WRITE , \n - MAP_SHARED | MAP_ANONYMOUS , - 1 , 0 ) ; \n + MAP_PRIVATE | MAP_ANONYMOUS , - 1 , 0 ) ; \n if ( p = = MAP_FAILED ) throw std : : bad_alloc ( ) ; \n return ( T * ) p ; \n }", "msg": "Don ' t attempt to mmap an anonymous shared piece of memory\n"}
{"diff": "a / lib / Immediate / Immediate . cpp \n  b / lib / Immediate / Immediate . cpp \n static void * loadRuntimeLib ( StringRef sharedLibName , \n \n void * swift : : immediate : : loadSwiftRuntime ( ArrayRef < std : : string > \n runtimeLibPaths ) { \n + # if defined ( _WIN32 ) \n + return loadRuntimeLib ( \" swiftCore \" LTDL_SHLIB_EXT , runtimeLibPaths ) ; \n + # else \n return loadRuntimeLib ( \" libswiftCore \" LTDL_SHLIB_EXT , runtimeLibPaths ) ; \n + # endif \n } \n \n static bool tryLoadLibrary ( LinkLibrary linkLib ,", "msg": "[ windows ] Use unprefixed library name for immediate mode .\n"}
{"diff": "a / xbmc / network / AirPlayServer . cpp \n  b / xbmc / network / AirPlayServer . cpp \n int CAirPlayServer : : CTCPClient : : ProcessRequest ( CStdString & responseHeader , \n CStdString authorization = m_httpParser - > getValue ( \" authorization \" ) ; \n int status = AIRPLAY_STATUS_OK ; \n bool needAuth = false ; \n + \n + if ( m_sessionId . IsEmpty ( ) ) \n + m_sessionId = \" 00000000 - 0000 - 0000 - 0000 - 000000000000 \" ; \n \n if ( ServerInstance - > m_usePassword & & ! m_bAuthenticated ) \n {", "msg": "[ airplay ] - handle empty session ids from itunes\n"}
{"diff": "a / src / app / commands / cmd_save_file . cpp \n  b / src / app / commands / cmd_save_file . cpp \n class SaveFileBaseCommand : public Command { \n { \n ContextWriter writer ( reader ) ; \n Document * documentWriter = writer . document ( ) ; \n + std : : string oldFilename = documentWriter - > getFilename ( ) ; \n \n / / Change the document file name \n documentWriter - > setFilename ( filename . c_str ( ) ) ; \n class SaveFileBaseCommand : public Command { \n / / Save the document \n save_document_in_background ( documentWriter , markAsSaved ) ; \n \n + if ( documentWriter - > isModified ( ) ) \n + documentWriter - > setFilename ( oldFilename ) ; \n + \n update_screen_for_document ( documentWriter ) ; \n } \n }", "msg": "Restore filename if \" save as \" fails\n"}
{"diff": "a / toolsrc / src / vcpkg / build . cpp \n  b / toolsrc / src / vcpkg / build . cpp \n namespace vcpkg : : Build \n const std : : string features = Strings : : join ( \" ; \" , config . feature_list ) ; \n abi_tag_entries . emplace_back ( AbiEntry { \" features \" , features } ) ; \n \n + if ( pre_build_info . public_abi_override ) \n + { \n + abi_tag_entries . emplace_back ( \n + AbiEntry { \n + \" public_abi_override \" , \n + pre_build_info . public_abi_override . value_or_exit ( VCPKG_LINE_INFO ) \n + } ) ; \n + } \n + \n if ( config . build_package_options . use_head_version = = UseHeadVersion : : YES ) \n abi_tag_entries . emplace_back ( AbiEntry { \" head \" , \" \" } ) ;", "msg": "Add public abi override into the private abi\n"}
{"diff": "a / Code / CryEngine / CryAction / GameVolumes / GameVolumesManager . cpp \n  b / Code / CryEngine / CryAction / GameVolumes / GameVolumesManager . cpp \n void CGameVolumesManager : : ResolveEntityIdsFromGUIDs ( ) \n for ( uint32 index = 0 ; index < count ; + + index ) \n { \n const EntityId entityId = gEnv - > pEntitySystem - > FindEntityByGuid ( m_volumesData [ index ] . entityGUID ) ; \n - CRY_ASSERT ( entityId ! = INVALID_ENTITYID ) ; \n + \n + / / This is a valid case for some volumes which are baked ( e . g . CLedgeObjectStatic ) and not spawned as entity . \n + if ( entityId = = INVALID_ENTITYID ) \n + continue ; \n + \n m_entityToIndexMap [ entityId ] = index ; \n } \n }", "msg": "! B ( CryAction ) ( CE - 17447 ) Fixed game volume manager not considering baked objects for entity id resolving .\n"}
{"diff": "a / modules / highgui / src / window_QT . cpp \n  b / modules / highgui / src / window_QT . cpp \n CV_IMPL void cvAddText ( const CvArr * img , const char * text , CvPoint org , CvFont * \n \" putText \" , \n autoBlockingConnection ( ) , \n Q_ARG ( void * , ( void * ) img ) , \n - Q_ARG ( QString , QString ( text ) ) , \n + Q_ARG ( QString , QString : : fromUtf8 ( text ) ) , \n Q_ARG ( QPoint , QPoint ( org . x , org . y ) ) , \n Q_ARG ( void * , ( void * ) font ) ) ; \n }", "msg": "In cvAddText , construct QString from \" text \" using fromUtf8 .\n"}
{"diff": "a / xbmc / music / windows / GUIWindowMusicBase . cpp \n  b / xbmc / music / windows / GUIWindowMusicBase . cpp \n void CGUIWindowMusicBase : : OnRemoveSource ( int iItem ) \n database . RemoveSongsFromPath ( m_vecItems - > Get ( iItem ) - > GetPath ( ) , songs , false ) ; \n database . CleanupOrphanedItems ( ) ; \n g_infoManager . ResetLibraryBools ( ) ; \n + m_vecItems - > RemoveDiscCache ( GetID ( ) ) ; \n } \n }", "msg": "CGUIWindowMusicBase : clear the cached source listing when removing a music source\n"}
{"diff": "a / sw . cpp \n  b / sw . cpp \n void build ( Solution & s ) \n libtesseract . Interface + = sw : : Shared , \" TESS_IMPORTS \" _d ; \n libtesseract . Private + = sw : : Shared , \" TESS_EXPORTS \" _d ; \n \n - libtesseract . Public + = \" org . sw . demo . danbloomberg . leptonica - 1 \" _dep ; \n + libtesseract . Public + = \" org . sw . demo . danbloomberg . leptonica - master \" _dep ; \n \n if ( s . Settings . TargetOS . Type = = OSType : : Windows ) \n libtesseract . Public + = \" ws2_32 . lib \" _l ;", "msg": "[ sw ] Depend on leptonica - master .\n"}
{"diff": "a / src / ExtendedTableWidget . cpp \n  b / src / ExtendedTableWidget . cpp \n void ExtendedTableWidget : : vscrollbarChanged ( int value ) \n \n int ExtendedTableWidget : : numVisibleRows ( ) const \n { \n - if ( ! isVisible ( ) ) \n + if ( ! isVisible ( ) | | ! model ( ) | | ! verticalHeader ( ) ) \n return 0 ; \n \n / / Get the row numbers of the rows currently visible at the top and the bottom of the widget", "msg": "Try to fix possible crash in cee3523f37bf89780e42fc65fd327c2e1ea3a752\n"}
{"diff": "a / editor / script_editor_debugger . cpp \n  b / editor / script_editor_debugger . cpp \n void ScriptEditorDebugger : : _parse_message ( const String & p_msg , const Array & p_da \n if ( var . is_zero ( ) ) { \n var = RES ( ) ; \n } else if ( var . get_type ( ) = = Variant : : STRING ) { \n - var = ResourceLoader : : load ( var ) ; \n + String path = var ; \n + if ( path . find ( \" : : \" ) ! = - 1 ) { \n + / / built - in resource \n + String base_path = path . get_slice ( \" : : \" , 0 ) ; \n + if ( ResourceLoader : : get_resource_type ( base_path ) = = \" PackedScene \" ) { \n + if ( ! EditorNode : : get_singleton ( ) - > is_scene_open ( base_path ) ) { \n + EditorNode : : get_singleton ( ) - > load_scene ( base_path ) ; \n + } \n + } else { \n + EditorNode : : get_singleton ( ) - > load_resource ( base_path ) ; \n + } \n + } \n + var = ResourceLoader : : load ( path ) ; \n \n if ( pinfo . hint_string = = \" Script \" ) \n debugObj - > set_script ( var ) ;", "msg": "Fixed variables with built - in resource in remote inspector\n"}
{"diff": "a / scene / gui / rich_text_label . cpp \n  b / scene / gui / rich_text_label . cpp \n void RichTextLabel : : _notification ( int p_what ) { \n \n switch ( p_what ) { \n \n + case NOTIFICATION_MOUSE_EXIT : { \n + if ( meta_hovering ) { \n + meta_hovering = NULL ; \n + emit_signal ( \" meta_hover_ended \" , current_meta ) ; \n + current_meta = false ; \n + update ( ) ; \n + } \n + } break ; \n case NOTIFICATION_RESIZED : { \n \n main - > first_invalid_line = 0 ; / / invalidate ALL", "msg": "Emits meta_hover_ended when mouse exit RichTextLabel\n"}
{"diff": "a / src / mongo / db / dbcommands . cpp \n  b / src / mongo / db / dbcommands . cpp \n namespace mongo { \n uassert ( 10040 , \" chunks out of order \" , n = = myn ) ; \n } \n \n + / / make a copy of obj since we access data in it while yielding \n + BSONObj owned = obj . getOwned ( ) ; \n int len ; \n - const char * data = obj [ \" data \" ] . binDataClean ( len ) ; \n + const char * data = owned [ \" data \" ] . binDataClean ( len ) ; \n \n ClientCursor : : YieldLock yield ( cc . get ( ) ) ; \n try {", "msg": "Make copy of chunk object before yielding in filemd5 command\n"}
{"diff": "a / cocos / editor - support / cocostudio / WidgetReader / Node3DReader / Node3DReader . cpp \n  b / cocos / editor - support / cocostudio / WidgetReader / Node3DReader / Node3DReader . cpp \n namespace cocostudio \n return _instanceNode3DReader ; \n } \n \n + void Node3DReader : : purge ( ) \n + { \n + CC_SAFE_DELETE ( _instanceNode3DReader ) ; \n + } \n + \n void Node3DReader : : destroyInstance ( ) \n { \n CC_SAFE_DELETE ( _instanceNode3DReader ) ;", "msg": "Reset method purge ( ) definition .\n"}
{"diff": "a / lib / SILPasses / Specializer . cpp \n  b / lib / SILPasses / Specializer . cpp \n \n # include \" swift / SIL / SILInstruction . h \" \n # include \" swift / SIL / SILModule . h \" \n # include \" swift / SILPasses / Passes . h \" \n - # include \" llvm / ADT / DenseSet . h \" \n # include \" llvm / ADT / Statistic . h \" \n + # include \" llvm / ADT / MapVector . h \" \n # include \" llvm / ADT / ImmutableSet . h \" \n # include \" llvm / Support / Debug . h \" \n using namespace swift ; \n struct SILSpecializer { \n } \n \n / / / Maps a function to all of the ApplyInst that call it . \n - llvm : : DenseMap < SILFunction * , AIList > ApplyInstMap ; \n + llvm : : MapVector < SILFunction * , AIList > ApplyInstMap ; \n } ; \n \n } / / end anonymous namespace .", "msg": "Make the order of specializing functions deterministic .\n"}
{"diff": "a / shell / dbshell . cpp \n  b / shell / dbshell . cpp \n int _main ( int argc , char * argv [ ] ) { \n \n shellHistoryInit ( ) ; \n \n + string prompt ; \n + \n / / v8 : : Handle < v8 : : Object > shellHelper = baseContext_ - > Global ( ) - > Get ( v8 : : String : : New ( \" shellHelper \" ) ) - > ToObject ( ) ; \n \n while ( 1 ) { \n int _main ( int argc , char * argv [ ] ) { \n / / shellMainScope - > localConnect ; \n / / DBClientWithCommands * c = getConnection ( JSContext * cx , JSObject * obj ) ; \n \n - string prompt ( sayReplSetMemberState ( ) + \" > \" ) ; \n - \n + if ( scope - > exec ( \" prompt \" , \" \" , false , false , false ) ) { \n + prompt = scope - > getString ( \" prompt \" ) ; \n + } else { \n + prompt = sayReplSetMemberState ( ) + \" > \" ; \n + } \n char * line = shellReadline ( prompt . c_str ( ) ) ; \n \n if ( line ) {", "msg": "SERVER - 3267 very basic custom prompt added\n"}
{"diff": "a / src / test / test_bitcoin . cpp \n  b / src / test / test_bitcoin . cpp \n TestingSetup : : TestingSetup ( const std : : string & chainName ) : BasicTestingSetup ( cha \n \n RegisterAllCoreRPCCommands ( tableRPC ) ; \n ClearDatadirCache ( ) ; \n - pathTemp = fs : : temp_directory_path ( ) / strprintf ( \" test_bitcoin_ % lu_ % i \" , ( unsigned long ) GetTime ( ) , ( int ) ( InsecureRandRange ( 100000 ) ) ) ; \n + pathTemp = fs : : temp_directory_path ( ) / strprintf ( \" test_bitcoin_ % lu_ % i \" , ( unsigned long ) GetTime ( ) , ( int ) ( InsecureRandRange ( 1 < < 30 ) ) ) ; \n fs : : create_directories ( pathTemp ) ; \n gArgs . ForceSetArg ( \" - datadir \" , pathTemp . string ( ) ) ;", "msg": "Increase entropy in test temp directory name\n"}
{"diff": "a / lang / mass_spring . cpp \n  b / lang / mass_spring . cpp \n TC_TEST ( \" mass_spring \" ) { \n fork2 . fixed ( j , 64 ) . place ( expr ) ; \n } ; \n \n + auto & fork3 = root . fixed ( i , max_n ) . fixed ( j , 8 ) ; \n + auto place_blocked = [ & ] ( Expr expr ) { \n + fork3 . fixed ( j , 8 ) . place ( expr ) ; \n + } ; \n + \n place_fixed ( l0 ) ; \n place_fixed ( stiffness ) ; \n for ( auto & e : K . entries ) { \n - place_fixed ( e ) ; \n + place_blocked ( e ) ; \n } \n \n auto & particle = root . fixed ( i , max_n ) ;", "msg": "Blocked storage of K : 20 % faster\n"}
{"diff": "a / src / mongo / s / commands_public . cpp \n  b / src / mongo / s / commands_public . cpp \n namespace mongo { \n * / \n if ( limit ! = 0 & & cmdObj [ \" skip \" ] . isNumber ( ) ) { \n long long skip = cmdObj [ \" skip \" ] . numberLong ( ) ; \n - verify ( skip > = 0 ) ; \n + uassert ( 16260 , \" skip has to be positive \" , skip > = 0 ) ; \n if ( limit > 0 ) \n limit + = skip ; \n else", "msg": "uassert instead of verify for invalid skip\n"}
{"diff": "a / stdlib / runtime / Casting . cpp \n  b / stdlib / runtime / Casting . cpp \n static bool _conformsToProtocols ( const OpaqueValue * value , \n return true ; \n } \n \n - static const OpaqueValue * \n - _dynamicCastToExistential ( const OpaqueValue * value , \n - const Metadata * sourceType , \n - const ExistentialTypeMetadata * targetType ) { \n - for ( unsigned i = 0 , n = targetType - > Protocols . NumProtocols ; i ! = n ; + + i ) { \n - auto * protocol = targetType - > Protocols [ i ] ; \n - if ( ! _conformsToProtocol ( value , sourceType , protocol , nullptr ) ) \n - return nullptr ; \n - } \n - \n - return value ; \n - } \n - \n static bool shouldDeallocateSource ( bool castSucceeded , DynamicCastFlags flags ) { \n return ( castSucceeded & & ( flags & DynamicCastFlags : : TakeOnSuccess ) ) | | \n ( ! castSucceeded & & ( flags & DynamicCastFlags : : DestroyOnFailure ) ) ;", "msg": "Runtime : Remove unused helper .\n"}
{"diff": "a / Marlin / ultralcd . cpp \n  b / Marlin / ultralcd . cpp \n void kill_screen ( const char * lcd_msg ) { \n / / Bed : \n / / \n # if TEMP_SENSOR_BED ! = 0 \n - MENU_MULTIPLIER_ITEM_EDIT ( int3 , MSG_BED , & thermalManager . target_temperature_bed , 0 , BED_MAXTEMP - 15 ) ; \n + MENU_MULTIPLIER_ITEM_EDIT_CALLBACK ( int3 , MSG_BED , & thermalManager . target_temperature_bed , 0 , BED_MAXTEMP - 15 , watch_temp_callback_bed ) ; \n # endif \n \n / /", "msg": "Watch bed temp also for Control menu item\n"}
{"diff": "a / db . cpp \n  b / db . cpp \n bool LoadWallet ( bool & fFirstRunRet ) \n keyUser . MakeNewKey ( ) ; \n if ( ! AddKey ( keyUser ) ) \n return false ; \n - if ( ! SetAddressBookName ( PubKeyToAddress ( keyUser . GetPubKey ( ) ) , \" Your Address \" ) ) \n + if ( ! SetAddressBookName ( PubKeyToAddress ( keyUser . GetPubKey ( ) ) , \" \" ) ) \n return false ; \n CWalletDB ( ) . WriteDefaultKey ( keyUser . GetPubKey ( ) ) ; \n }", "msg": "do not create ' Your Address ' account\n"}
{"diff": "a / Marlin / twibus . cpp \n  b / Marlin / twibus . cpp \n void TWIBus : : addstring ( char str [ ] ) { \n } \n \n void TWIBus : : send ( ) { \n - if ( ! this - > addr ) return ; \n - \n # if ENABLED ( DEBUG_TWIBUS ) \n debug ( PSTR ( \" send \" ) , this - > addr ) ; \n # endif", "msg": "Allow send to i2c address 0 ( broadcast )\n"}
{"diff": "a / xbmc / guilib / GUITextBox . cpp \n  b / xbmc / guilib / GUITextBox . cpp \n bool CGUITextBox : : OnMessage ( CGUIMessage & message ) \n m_scrollOffset = 0 ; \n ResetAutoScrolling ( ) ; \n CGUITextLayout : : Reset ( ) ; \n - if ( m_pageControl ) \n - { \n - CGUIMessage msg ( GUI_MSG_LABEL_RESET , GetID ( ) , m_pageControl , m_itemsPerPage , m_lines . size ( ) ) ; \n - SendWindowMessage ( msg ) ; \n - } \n + UpdatePageControl ( ) ; \n + SetInvalid ( ) ; \n } \n \n if ( message . GetMessage ( ) = = GUI_MSG_PAGE_CHANGE )", "msg": "[ textbox ] remove duplicate code\n"}
{"diff": "a / imgui . cpp \n  b / imgui . cpp \n bool ImGui : : CloseButton ( ImGuiID id , const ImVec2 & pos , float radius ) \n \n / / Render \n const ImU32 col = GetColorU32 ( ( held & & hovered ) ? ImGuiCol_CloseButtonActive : hovered ? ImGuiCol_CloseButtonHovered : ImGuiCol_CloseButton ) ; \n - const ImVec2 center = bb . GetCenter ( ) ; \n + ImVec2 center = bb . GetCenter ( ) ; \n window - > DrawList - > AddCircleFilled ( center , ImMax ( 2 . 0f , radius ) , col , 12 ) ; \n \n const float cross_extent = ( radius * 0 . 7071f ) - 1 . 0f ; \n if ( hovered ) \n { \n + center - = ImVec2 ( 0 . 5f , 0 . 5f ) ; \n window - > DrawList - > AddLine ( center + ImVec2 ( + cross_extent , + cross_extent ) , center + ImVec2 ( - cross_extent , - cross_extent ) , GetColorU32 ( ImGuiCol_Text ) ) ; \n window - > DrawList - > AddLine ( center + ImVec2 ( + cross_extent , - cross_extent ) , center + ImVec2 ( - cross_extent , + cross_extent ) , GetColorU32 ( ImGuiCol_Text ) ) ; \n }", "msg": "CloseButton : Fixed cross positioning .\n"}
{"diff": "a / src / chainparams . cpp \n  b / src / chainparams . cpp \n class SigNetParams : public CChainParams { \n bin = ParseHex ( \" 512103ad5e0edad18cb1f0fc0d28a3d4f1f3e445640337489abb10404f2d1e086be430210359ef5021964fe22d6f8e05b2463c9540ce96883fe3b278760f048f5189f2e6c452ae \" ) ; \n vSeeds . emplace_back ( \" 178 . 128 . 221 . 177 \" ) ; \n vSeeds . emplace_back ( \" 2a01 : 7c8 : d005 : 390 : : 5 \" ) ; \n - vSeeds . emplace_back ( \" ntv3mtqw5wt63red . onion : 38333 \" ) ; \n + vSeeds . emplace_back ( \" v7ajjeirttkbnt32wpy3c6w3emwnfr3fkla7hpxcfokr3ysd3kqtzmqd . onion : 38333 \" ) ; \n \n consensus . nMinimumChainWork = uint256S ( \" 0x00000000000000000000000000000000000000000000000000000019fd16269a \" ) ; \n consensus . defaultAssumeValid = uint256S ( \" 0x0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020 \" ) ; / / 9434", "msg": "Merge : Move signet onion seed from v2 to v3\n"}
{"diff": "a / PowerEditor / src / ScitillaComponent / AutoCompletion . cpp \n  b / PowerEditor / src / ScitillaComponent / AutoCompletion . cpp \n void AutoCompletion : : getCloseTag ( char * closeTag , size_t closeTagSize , size_t car \n if ( tagHead [ 1 ] = = ' / ' ) / / \" < / toto > \" will be ignored \n return ; \n \n + if ( tagHead [ 1 ] = = ' ? ' ) / / \" < ? \" ( Processing Instructions ) will be ignored \n + return ; \n + \n if ( strncmp ( tagHead , \" < ! - - \" , 4 ) = = 0 ) / / Comments will be ignored \n return ;", "msg": "Skip auto - complete of XML processing instructions\n"}
{"diff": "a / stdlib / public / runtime / Metadata . cpp \n  b / stdlib / public / runtime / Metadata . cpp \n using namespace metadataimpl ; \n void * MetadataAllocator : : alloc ( size_t size ) { \n static const uintptr_t pagesizeMask = sysconf ( _SC_PAGESIZE ) - 1 ; \n \n + / / If the requested size is a page or larger , map page ( s ) for it \n + / / specifically . \n + if ( LLVM_UNLIKELY ( size > pagesizeMask ) ) { \n + auto mem = mmap ( nullptr , ( size + pagesizeMask ) & ~ pagesizeMask , \n + PROT_READ | PROT_WRITE , MAP_ANON | MAP_PRIVATE , \n + - 1 , 0 ) ; \n + if ( next = = MAP_FAILED ) \n + crash ( \" unable to allocate memory for metadata cache \" ) ; \n + return mem ; \n + } \n + \n char * end = next + size ; \n \n / / Allocate a new page if we need one .", "msg": "Runtime : Handle large metadata allocations .\n"}
{"diff": "a / util / mmap . cpp \n  b / util / mmap . cpp \n namespace mongo { \n \n static set < MongoFile * > mmfiles ; \n static RWLock mmmutex ( \" rw : mmmutex \" ) ; \n - static mutex flush_mutex ( \" rw : flush_mutex \" ) ; \n \n void MongoFile : : destroyed ( ) { \n rwlock lk ( mmmutex , true ) ; \n namespace mongo { \n / * static * / int MongoFile : : flushAll ( bool sync ) { \n if ( ! sync ) { \n int num = 0 ; \n - scoped_lock flushlk ( flush_mutex ) ; \n rwlock lk ( mmmutex , false ) ; \n for ( set < MongoFile * > : : iterator i = mmfiles . begin ( ) ; i ! = mmfiles . end ( ) ; i + + ) { \n num + + ; \n namespace mongo { \n if ( ! f . get ( ) ) \n break ; \n \n - { \n - scoped_lock flushlk ( flush_mutex ) ; \n - f - > flush ( ) ; \n - } \n + f - > flush ( ) ; \n } \n return seen . size ( ) ; \n }", "msg": "Revert \" make sure only one flush happens at a time SERVER - 1163 \"\n"}
{"diff": "a / editor / plugins / animation_player_editor_plugin . cpp \n  b / editor / plugins / animation_player_editor_plugin . cpp \n void AnimationPlayerEditor : : _update_player ( ) { \n save_anim - > set_disabled ( animlist . size ( ) = = 0 ) ; \n tool_anim - > set_disabled ( player = = NULL ) ; \n onion_skinning - > set_disabled ( player = = NULL ) ; \n + pin - > set_disabled ( player = = NULL ) ; \n \n int active_idx = - 1 ; \n for ( List < StringName > : : Element * E = animlist . front ( ) ; E ; E = E - > next ( ) ) {", "msg": "Made the Pin button disable when no AnimationPlayer is selected .\n"}
{"diff": "a / src / app / file / ase_format . cpp \n  b / src / app / file / ase_format . cpp \n static bool ase_file_read_header ( FILE * f , ASE_Header * header ) \n \n header - > size = fgetl ( f ) ; \n header - > magic = fgetw ( f ) ; \n + \n + / / Developers can open any . ase file \n + # if ! defined ( ENABLE_DEVMODE ) \n if ( header - > magic ! = ASE_FILE_MAGIC ) \n return false ; \n + # endif \n \n header - > frames = fgetw ( f ) ; \n header - > width = fgetw ( f ) ; \n static bool ase_file_read_header ( FILE * f , ASE_Header * header ) \n header - > pixel_height = 1 ; \n } \n \n + # if defined ( ENABLE_DEVMODE ) \n + / / This is useful to read broken . ase files \n + if ( header - > magic ! = ASE_FILE_MAGIC ) { \n + header - > frames = 256 ; / / Frames number might be not enought for some files \n + header - > width = 1024 ; / / Size doesn ' t matter , the sprite can be crop \n + header - > height = 1024 ; \n + } \n + # endif \n + \n fseek ( f , header - > pos + 128 , SEEK_SET ) ; \n return true ; \n }", "msg": "Add possibility to open broken . ase files on devmode\n"}
{"diff": "a / lib / Sema / TypeCheckAttr . cpp \n  b / lib / Sema / TypeCheckAttr . cpp \n class AttributeEarlyChecker : public AttributeVisitor < AttributeEarlyChecker > { \n / / ' final ' only makes sense in the context of a class declaration . \n / / Reject it on global functions , protocols , structs , enums , etc . \n if ( ! D - > getDeclContext ( ) - > getAsClassOrClassExtensionContext ( ) ) { \n - if ( D - > getDeclContext ( ) - > getAsProtocolExtensionContext ( ) ) \n + if ( TC . Context . isSwiftVersion3 ( ) & & \n + D - > getDeclContext ( ) - > getAsProtocolExtensionContext ( ) ) \n TC . diagnose ( attr - > getLocation ( ) , \n diag : : protocol_extension_cannot_be_final ) \n . fixItRemove ( attr - > getRange ( ) ) ;", "msg": "Only emit compatibility warning in Swift 3 mode\n"}
{"diff": "a / src / mongo / shell / shell_utils_extended . cpp \n  b / src / mongo / shell / shell_utils_extended . cpp \n namespace mongo { \n * / \n BSONObj fuzzFile ( const BSONObj & args , void * data ) { \n uassert ( 13619 , \" fuzzFile takes 2 arguments \" , args . nFields ( ) = = 2 ) ; \n - shared_ptr < File > f ( new File ( ) ) ; \n + scoped_ptr < File > f ( new File ( ) ) ; \n f - > open ( args . getStringField ( \" 0 \" ) ) ; \n uassert ( 13620 , \" couldn ' t open file to fuzz \" , ! f - > bad ( ) & & f - > is_open ( ) ) ;", "msg": "Use scoped_ptr not shared_ptr in fuzzFile ( ) .\n"}
{"diff": "a / fdbserver / ClusterController . actor . cpp \n  b / fdbserver / ClusterController . actor . cpp \n ACTOR Future < Void > failureDetectionServer ( UID uniqueID , ClusterControllerData * \n / / TraceEvent ( \" FailureDetectionPoll \" , uniqueID ) . detail ( \" PivotDelay \" , pivotDelay ) . detail ( \" Clients \" , currentStatus . size ( ) ) ; \n / / TraceEvent ( \" FailureDetectionAcceptableDelay \" ) . detail ( \" Delay \" , acceptableDelay1000 ) ; \n \n - bool tooManyLogGenerations = std : : max ( self - > db . unfinishedRecoveries , self - > db . logGenerations ) > CLIENT_KNOBS - > FAILURE_MAX_GENERATIONS ; \n + bool tooManyLogGenerations = ( std : : max ( self - > db . unfinishedRecoveries , self - > db . logGenerations ) > CLIENT_KNOBS - > FAILURE_MAX_GENERATIONS ) | | \n + ( now ( ) - self - > startTime < CLIENT_KNOBS - > FAILURE_EMERGENCY_DELAY ) ; \n \n for ( auto it = currentStatus . begin ( ) ; it ! = currentStatus . end ( ) ; ) { \n double delay = t - it - > second . lastRequestTime ;", "msg": "Do not allow the cluster controller to mark any process as failed within 30 seconds of startup\n"}
{"diff": "a / Marlin / src / Marlin . cpp \n  b / Marlin / src / Marlin . cpp \n void kill ( const char * lcd_msg ) { \n # endif \n \n # if HAS_POWER_SWITCH \n - SET_INPUT ( PS_ON_PIN ) ; \n + PSU_OFF ( ) ; \n # endif \n \n # if HAS_SUICIDE", "msg": "Turn power off in ` kill ` instead of setting PS_ON to input\n"}
{"diff": "a / osquery / database / db_handle . cpp \n  b / osquery / database / db_handle . cpp \n FLAG_ALIAS ( bool , use_in_memory_database , database_in_memory ) ; \n DBHandle : : DBHandle ( const std : : string & path , bool in_memory ) { \n options_ . create_if_missing = true ; \n options_ . create_missing_column_families = true ; \n + options_ . info_log_level = rocksdb : : WARN_LEVEL ; \n + options_ . log_file_time_to_roll = 0 ; \n + options_ . keep_log_file_num = 10 ; \n + options_ . max_log_file_size = 1024 * 1024 * 1 ; \n \n if ( in_memory ) { \n / / Remove when MemEnv is included in librocksdb", "msg": "Limit the number of RocksDB log files\n"}
{"diff": "a / lib / Frontend / CompilerInvocation . cpp \n  b / lib / Frontend / CompilerInvocation . cpp \n static bool ParseLangArgs ( LangOptions & Opts , ArgList & Args , \n = A - > getOption ( ) . matches ( OPT_enable_access_control ) ; \n } \n \n - Opts . ImportUnions = Args . hasArg ( OPT_enable_union_import ) ; \n + Opts . ImportUnions | = Args . hasArg ( OPT_enable_union_import ) ; \n \n - Opts . EnableDynamic = Args . hasArg ( OPT_enable_dynamic ) ; \n + Opts . EnableDynamic | = Args . hasArg ( OPT_enable_dynamic ) ; \n \n Opts . DebugConstraintSolver | = Args . hasArg ( OPT_debug_constraints ) ;", "msg": "Make it easier to tweak the EnableDynamic and ImportUnion flags in testing .\n"}
{"diff": "a / xbmc / guilib / GraphicContext . cpp \n  b / xbmc / guilib / GraphicContext . cpp \n void CGraphicContext : : ResetOverscan ( RESOLUTION res , OVERSCAN & overscan ) \n overscan . right = 960 ; \n overscan . bottom = 1080 ; \n break ; \n + case RES_HDTV_1080pTB : \n + overscan . right = 1920 ; \n + overscan . bottom = 540 ; \n + break ; \n case RES_HDTV_720p : \n overscan . right = 1280 ; \n overscan . bottom = 720 ;", "msg": "[ rbp ] added missing mode from b0f57b850b5b51710f84e94e94a5125d82017580\n"}
{"diff": "a / xbmc / filesystem / posix / PosixDirectory . cpp \n  b / xbmc / filesystem / posix / PosixDirectory . cpp \n bool CPosixDirectory : : Remove ( const CURL & url ) \n \n bool CPosixDirectory : : Exists ( const CURL & url ) \n { \n + std : : string path = url . Get ( ) ; \n + \n + if ( IsAliasShortcut ( path ) ) \n + TranslateAliasShortcut ( path ) ; \n + \n struct stat buffer ; \n - if ( stat ( url . Get ( ) . c_str ( ) , & buffer ) ! = 0 ) \n + if ( stat ( path . c_str ( ) , & buffer ) ! = 0 ) \n return false ; \n return S_ISDIR ( buffer . st_mode ) ? true : false ; \n }", "msg": "[ posixdirectory ] changed IsAliasShortcut handling\n"}
{"diff": "a / src / runtime / base / server / http_protocol . cpp \n  b / src / runtime / base / server / http_protocol . cpp \n void HttpProtocol : : PrepareSystemVariables ( Transport * transport , \n if ( server . asArrRef ( ) . exists ( key ) ) { \n if ( ! ( + + bad_request_count % RuntimeOption : : LogHeaderMangle ) ) { \n Logger : : Warning ( \n + \" HeaderMangle warning : \" \n \" The header % s overwrote another header which mapped to the same \" \n \" key . This happens because PHP normalises - to _ , ie AN_EXAMPLE \" \n \" and AN - EXAMPLE are equivalent . You should treat this as \"", "msg": "Made the log line for HeaderMangle more greppable\n"}
{"diff": "a / lib / SILOptimizer / IPO / GlobalOpt . cpp \n  b / lib / SILOptimizer / IPO / GlobalOpt . cpp \n class SILGlobalOpt { \n / / / The set of functions that have had their loops analyzed . \n llvm : : DenseSet < SILFunction * > LoopCheckedFunctions ; \n \n - / / / Keep track of cold blocks . \n - ColdBlockInfo ColdBlocks ; \n - \n - / / / Whether we see a \" once \" call to callees that we currently don ' t handle . \n + / / / Whether we have seen any \" once \" calls to callees that we currently don ' t \n + / / / handle . \n bool UnhandledOnceCallee = false ; \n \n / / / A map from a globalinit_func to the number of times \" once \" has called the \n class SILGlobalOpt { \n llvm : : DenseMap < SILFunction * , unsigned > InitializerCount ; \n public : \n SILGlobalOpt ( SILModule * M , DominanceAnalysis * DA ) \n - : Module ( M ) , DA ( DA ) , ColdBlocks ( DA ) { } \n + : Module ( M ) , DA ( DA ) { } \n \n bool run ( ) ;", "msg": "[ globalopt ] Eliminate unused field .\n"}
{"diff": "a / lib / ClangImporter / ImportDecl . cpp \n  b / lib / ClangImporter / ImportDecl . cpp \n namespace { \n } \n } \n \n - if ( getter & & getterIndices ) \n - getterThunk = buildGetterThunk ( getter , dc , getterIndices ) ; \n - if ( setter & & setterIndices ) \n + getterThunk = buildGetterThunk ( getter , dc , getterIndices ) ; \n + if ( setter ) \n setterThunk = buildSetterThunk ( setter , dc , setterIndices ) ; \n \n / / Build the subscript declaration . \n namespace { \n subscript - > setOverriddenDecl ( parentSub ) ; \n if ( auto parentGetter = parentSub - > getGetter ( ) ) { \n if ( getterThunk ) \n - getterThunk - > setOverriddenDecl ( parentGetter ) ; \n + getterThunk - > setOverriddenDecl ( parentGetter ) ; \n } \n if ( auto parentSetter = parentSub - > getSetter ( ) ) { \n if ( setterThunk )", "msg": "Clean up handling of getter / setter thunks . < rdar : / / problem / 14109713 >\n"}
{"diff": "a / xbmc / guilib / GUIWindow . cpp \n  b / xbmc / guilib / GUIWindow . cpp \n bool CGUIWindow : : Load ( TiXmlElement * pRootElement ) \n return false ; \n } \n \n + / / we must create copy of root element as we will manipulate it when resolving includes \n + / / and we don ' t want original root element to change \n + pRootElement = ( TiXmlElement * ) pRootElement - > Clone ( ) ; \n + \n / / set the scaling resolution so that any control creation or initialisation can \n / / be done with respect to the correct aspect ratio \n g_graphicsContext . SetScalingResolution ( m_coordsRes , m_needsScaling ) ; \n bool CGUIWindow : : Load ( TiXmlElement * pRootElement ) \n \n m_windowLoaded = true ; \n OnWindowLoaded ( ) ; \n + delete pRootElement ; \n return true ; \n }", "msg": "CGUIWindow : resolve includes on copy of xml element to avoid manipulation of stored xml element\n"}
{"diff": "a / util / miniwebserver . cpp \n  b / util / miniwebserver . cpp \n namespace mongo { \n string responseMsg ; \n int responseCode = 599 ; \n vector < string > headers ; \n - doRequest ( buf , parseURL ( buf ) , responseMsg , responseCode , headers , from ) ; \n + \n + try { \n + doRequest ( buf , parseURL ( buf ) , responseMsg , responseCode , headers , from ) ; \n + } \n + catch ( std : : exception & e ) { \n + responseCode = 500 ; \n + responseMsg = \" error loading page : \" ; \n + responseMsg + = e . what ( ) ; \n + } \n + catch ( std : : exception & e ) { \n + responseCode = 500 ; \n + responseMsg = \" error loading page : \" ; \n + responseMsg + = e . what ( ) ; \n + } \n \n stringstream ss ; \n ss < < \" HTTP / 1 . 0 \" < < responseCode ;", "msg": "catch exceptions in webserver SERVER - 551\n"}
{"diff": "a / s / chunk . cpp \n  b / s / chunk . cpp \n namespace mongo { \n \n int nc = numChunks ( ) ; \n \n - if ( nc < 16 ) { \n + if ( nc < 10 ) { \n splitThreshold = max ( splitThreshold / 4 , minChunkSize ) ; \n } \n - else if ( nc < 32 ) { \n + else if ( nc < 20 ) { \n splitThreshold = max ( splitThreshold / 2 , minChunkSize ) ; \n }", "msg": "Revert \" increase threshold for making chunks smaller \"\n"}
{"diff": "a / editor / editor_node . cpp \n  b / editor / editor_node . cpp \n EditorNode : : EditorNode ( ) { \n dock_tab_move_left - > set_focus_mode ( Control : : FOCUS_NONE ) ; \n dock_tab_move_left - > connect ( \" pressed \" , this , \" _dock_move_left \" ) ; \n dock_hb - > add_child ( dock_tab_move_left ) ; \n - dock_hb - > add_spacer ( ) ; \n + \n + Label * dock_label = memnew ( Label ) ; \n + dock_label - > set_text ( TTR ( \" Dock Position \" ) ) ; \n + dock_label - > set_h_size_flags ( Control : : SIZE_EXPAND_FILL ) ; \n + dock_hb - > add_child ( dock_label ) ; \n + \n dock_tab_move_right = memnew ( ToolButton ) ; \n dock_tab_move_right - > set_icon ( theme - > get_icon ( \" Forward \" , \" EditorIcons \" ) ) ; \n dock_tab_move_right - > set_focus_mode ( Control : : FOCUS_NONE ) ;", "msg": "Added a label to the Dock Positioner .\n"}
{"diff": "a / lib / AST / ASTPrinter . cpp \n  b / lib / AST / ASTPrinter . cpp \n void PrintAST : : visitSubscriptDecl ( SubscriptDecl * decl ) { \n recordDeclLoc ( decl , [ & ] { \n Printer < < \" subscript \" ; \n } , [ & ] { / / Parameters \n - printParameterList ( decl - > getIndices ( ) , decl - > getIndicesInterfaceType ( ) , \n + printParameterList ( decl - > getIndices ( ) , \n + decl - > hasInterfaceType ( ) \n + ? decl - > getIndicesInterfaceType ( ) \n + : nullptr , \n / * isCurried = * / false , \n / * isAPINameByDefault * / [ ] ( ) - > bool { return false ; } ) ; \n } ) ;", "msg": "[ AST Printer ] Print non - type - checked subscript declarations .\n"}
{"diff": "a / libraries / chain / contracts / eosio_contract . cpp \n  b / libraries / chain / contracts / eosio_contract . cpp \n void apply_eosio_postrecovery ( apply_context & context ) { \n auto data = get_abi_serializer ( ) . variant_to_binary ( \" pending_recovery \" , record_data ) ; \n const uint64_t id = account ; \n const uint64_t table = N ( recovery ) ; \n - const auto payer = config : : system_account_name ; \n + const auto payer = account ; \n const auto iter = context . db_find_i64 ( config : : system_account_name , account , table , id ) ; \n if ( iter = = - 1 ) { \n context . db_store_i64 ( account , table , payer , id , ( const char * ) data . data ( ) , data . size ( ) ) ;", "msg": "Changed recovery payer to be requesting account .\n"}
{"diff": "a / samples / c / tree_engine . cpp \n  b / samples / c / tree_engine . cpp \n int main ( int argc , char * * argv ) \n print_result ( rtrees . calc_error ( & data , CV_TRAIN_ERROR ) , rtrees . calc_error ( & data , CV_TEST_ERROR ) , rtrees . get_var_importance ( ) ) ; \n \n printf ( \" = = = = = = ERTREES = = = = = \\ n \" ) ; \n - ertrees . train ( & data , CvRTParams ( 10 , 2 , 0 , false , 16 , 0 , true , 0 , 100 , 0 , CV_TERMCRIT_ITER ) ) ; \n + ertrees . train ( & data , CvRTParams ( 18 , 2 , 0 , false , 16 , 0 , true , 0 , 100 , 0 , CV_TERMCRIT_ITER ) ) ; \n print_result ( ertrees . calc_error ( & data , CV_TRAIN_ERROR ) , ertrees . calc_error ( & data , CV_TEST_ERROR ) , ertrees . get_var_importance ( ) ) ; \n \n printf ( \" = = = = = = GBTREES = = = = = \\ n \" ) ;", "msg": "increased the trees number for ERTrees\n"}
{"diff": "a / lib / AST / ProtocolConformance . cpp \n  b / lib / AST / ProtocolConformance . cpp \n void SpecializedProtocolConformance : : computeConditionalRequirements ( ) const { \n auto & ctxt = getProtocol ( ) - > getASTContext ( ) ; \n ConditionalRequirements = ctxt . AllocateCopy ( newReqs ) ; \n } else { \n - ConditionalRequirements = { } ; \n + ConditionalRequirements = Optional < ArrayRef < Requirement > > ( ) ; \n } \n }", "msg": "[ master - next ] Adjust syntax for setting an Optional member\n"}
{"diff": "a / util / file_allocator . cpp \n  b / util / file_allocator . cpp \n namespace mongo { \n < < \" took \" < < ( ( double ) t . millis ( ) ) / 1000 . 0 < < \" secs \" \n < < endl ; \n \n - \n + / / no longer in a failed state . allow new writers . \n + fa - > _failed = false ; \n } \n catch ( . . . ) { \n log ( ) < < \" error failed to allocate new file : \" < < name \n < < \" size : \" < < size < < ' ' < < errnoWithDescription ( ) < < endl ; \n + log ( ) < < \" will try again in 10 seconds \" < < endl ; \n try { \n if ( tmp . size ( ) ) \n BOOST_CHECK_EXCEPTION ( boost : : filesystem : : remove ( tmp ) ) ; \n namespace mongo { \n fa - > _pendingUpdated . notify_all ( ) ; \n \n \n - / / TODO : we should sleep and continue rather than stop \n - / / space might become available \n - return ; / / no more allocation \n + sleepsecs ( 10 ) ; \n + continue ; \n } \n \n {", "msg": "Keep trying to allocate new file SERVER - 2609\n"}
{"diff": "a / Telegram / SourceFiles / history / view / history_view_list_widget . cpp \n  b / Telegram / SourceFiles / history / view / history_view_list_widget . cpp \n void ListWidget : : elementStartStickerLoop ( not_null < const Element * > view ) { \n } \n \n void ListWidget : : elementShowPollResults ( \n - not_null < PollData * > poll , \n - FullMsgId context ) { \n + not_null < PollData * > poll , \n + FullMsgId context ) { \n + _controller - > showPollResults ( poll , context ) ; \n } \n \n void ListWidget : : elementShowTooltip (", "msg": "Fix poll results opening from pinned section .\n"}
{"diff": "a / xbmc / cores / dvdplayer / DVDPlayer . cpp \n  b / xbmc / cores / dvdplayer / DVDPlayer . cpp \n bool CDVDPlayer : : OpenVideoStream ( int iStream , int source ) \n if ( aspect ! = 0 . 0 ) \n hint . aspect = aspect ; \n hint . software = true ; \n - hint . stills = true ; \n + hint . stills = static_cast < CDVDInputStreamNavigator * > ( m_pInputStream ) - > IsInMenu ( ) ; \n } \n \n if ( m_CurrentVideo . id < 0", "msg": "changed : allow use of libavcodec for dvd decoding of non menu items\n"}
{"diff": "a / hphp / util / light - process . cpp \n  b / hphp / util / light - process . cpp \n pid_t LightProcess : : proc_open ( const char * cmd , const std : : vector < int > & created , \n } \n return - 1 ; \n } \n - always_assert ( buf = = \" success \" ) ; \n + always_assert_flog ( buf = = \" success \" , \n + \" Unexpected message from light process : ` { } ' \" , buf ) ; \n int64_t pid = - 1 ; \n lwp_read_int64 ( fin , pid ) ; \n always_assert ( pid ) ;", "msg": "Expand assert in LightProcess : : proc_open\n"}
{"diff": "a / modules / calib3d / src / sqpnp . cpp \n  b / modules / calib3d / src / sqpnp . cpp \n void PoseSolver : : computeRowAndNullspace ( const cv : : Matx < double , 9 , 1 > & r , \n void PoseSolver : : nearestRotationMatrix ( const cv : : Matx < double , 9 , 1 > & e , \n cv : : Matx < double , 9 , 1 > & r ) \n { \n - register int i ; \n + int i ; \n double l , lprev , det_e , e_sq , adj_e_sq , adj_e [ 9 ] ; \n \n / / e ' s adjoint", "msg": "calib3d : eliminate ' register ' build warning\n"}
{"diff": "a / hphp / runtime / vm / jit / irgen - builtin . cpp \n  b / hphp / runtime / vm / jit / irgen - builtin . cpp \n void emitNativeImpl ( IRGS & env ) { \n return ; \n } \n \n + / / CallBuiltin doesn ' t understand IDL instance methods that have variable \n + / / arguments . \n + if ( auto const info = callee - > methInfo ( ) ) { \n + if ( info - > attribute & ( ClassInfo : : VariableArguments | \n + ClassInfo : : RefVariableArguments ) ) { \n + genericNativeImpl ( ) ; \n + return ; \n + } \n + } \n + \n auto thiz = callee - > isMethod ( ) & & ( ! callee - > isStatic ( ) | | callee - > isNative ( ) ) \n ? gen ( env , LdCtx , fp ( env ) ) : nullptr ; \n auto const numParams = gen ( env , LdARNumParams , fp ( env ) ) ;", "msg": "Use generic native implmentation for vararg IDL instance methods\n"}
{"diff": "a / editor / plugins / tile_set_editor_plugin . cpp \n  b / editor / plugins / tile_set_editor_plugin . cpp \n AutotileEditor : : AutotileEditor ( EditorNode * p_editor ) { \n property_editor = memnew ( PropertyEditor ) ; \n property_editor - > set_v_size_flags ( SIZE_EXPAND_FILL ) ; \n property_editor - > set_h_size_flags ( SIZE_EXPAND_FILL ) ; \n + property_editor - > set_custom_minimum_size ( Size2 ( 10 , 70 ) ) ; \n split - > add_child ( property_editor ) ; \n \n helper = memnew ( AutotileEditorHelper ( this ) ) ;", "msg": "prevent autotile properties out of bounds\n"}
{"diff": "a / src / wallet / wallet . cpp \n  b / src / wallet / wallet . cpp \n \n / / Copyright ( c ) 2009 - 2010 Satoshi Nakamoto \n - / / Copyright ( c ) 2009 - 2018 The Bitcoin Core developers \n + / / Copyright ( c ) 2009 - 2019 The Bitcoin Core developers \n / / Distributed under the MIT software license , see the accompanying \n / / file COPYING or http : / / www . opensource . org / licenses / mit - license . php . \n \n # include < wallet / wallet . h > \n \n # include < chain . h > \n - # include < checkpoints . h > \n # include < consensus / consensus . h > \n # include < consensus / validation . h > \n # include < fs . h >", "msg": "wallet : Remove unused import checkpoints . h\n"}
{"diff": "a / lib / SILPasses / COWArrayOpt . cpp \n  b / lib / SILPasses / COWArrayOpt . cpp \n class SwiftArrayOptPass : public SILFunctionTransform { \n DominanceAnalysis * DA = PM - > getAnalysis < DominanceAnalysis > ( ) ; \n SILLoopAnalysis * LA = PM - > getAnalysis < SILLoopAnalysis > ( ) ; \n SILLoopInfo * LI = LA - > getLoopInfo ( getFunction ( ) ) ; \n - CallGraph * CG = PM - > getAnalysis < CallGraphAnalysis > ( ) - > getCallGraphOrNull ( ) ; \n + CallGraphAnalysis * CGA = PM - > getAnalysis < CallGraphAnalysis > ( ) ; \n + CallGraph * CG = CGA - > getCallGraphOrNull ( ) ; \n \n bool HasChanged = false ; \n \n class SwiftArrayOptPass : public SILFunctionTransform { \n if ( HasChanged ) { \n / / We preserve the dominator tree . Let ' s invalidate everything else . \n DA - > lockInvalidation ( ) ; \n + CGA - > lockInvalidation ( ) ; \n invalidateAnalysis ( SILAnalysis : : PreserveKind : : Nothing ) ; \n + CGA - > unlockInvalidation ( ) ; \n DA - > unlockInvalidation ( ) ; \n } \n }", "msg": "Lock invalidations of the call graph during COWArrayOpt .\n"}
{"diff": "a / src / catch2 / internal / catch_output_redirect . cpp \n  b / src / catch2 / internal / catch_output_redirect . cpp \n namespace Catch { \n if ( tmpnam_s ( m_buffer ) ) { \n CATCH_RUNTIME_ERROR ( \" Could not get a temp filename \" ) ; \n } \n - if ( fopen_s ( & m_file , m_buffer , \" w \" ) ) { \n + if ( fopen_s ( & m_file , m_buffer , \" w + \" ) ) { \n char buffer [ 100 ] ; \n if ( strerror_s ( buffer , errno ) ) { \n CATCH_RUNTIME_ERROR ( \" Could not translate errno to a string \" ) ;", "msg": "Make experimental capture work on Windows with read - write temp file behavior\n"}
{"diff": "a / scene / main / viewport . cpp \n  b / scene / main / viewport . cpp \n Control * Viewport : : get_modal_stack_top ( ) const { \n } \n \n String Viewport : : get_configuration_warning ( ) const { \n - \n / * if ( get_parent ( ) & & ! Object : : cast_to < Control > ( get_parent ( ) ) & & ! render_target ) { \n \n return TTR ( \" This viewport is not set as render target . If you intend for it to display its contents directly to the screen , make it a child of a Control so it can obtain a size . Otherwise , make it a RenderTarget and assign its internal texture to some node for display . \" ) ; \n } * / \n \n + if ( size . x = = 0 | | size . y = = 0 ) { \n + return TTR ( \" This viewport can ' t render anything . \\ nConsider increasing the size . \" ) ; \n + } \n return String ( ) ; \n }", "msg": "Add size warning to Viewport Node\n"}
{"diff": "a / unittests / runtime / Metadata . cpp \n  b / unittests / runtime / Metadata . cpp \n ProtocolDescriptor ProtocolNoWitnessTable { \n . withDispatchStrategy ( ProtocolDispatchStrategy : : ObjC ) \n } ; \n \n - # if 0 / / disabled because of rdar : / / problem / 31759879 \n - \n TEST ( MetadataTest , getExistentialMetadata ) { \n const ProtocolDescriptor * protoList1 [ ] = { } ; \n RaceTest_ExpectEqual < const ExistentialTypeMetadata * > ( \n TEST ( MetadataTest , getExistentialMetadata ) { \n } ) ; \n } \n \n - # endif \n - \n static SWIFT_CC ( swift ) void destroySuperclass ( SWIFT_CONTEXT HeapObject * toDestroy ) { } \n \n struct {", "msg": "Revert \" disabled flaky test \"\n"}
{"diff": "a / projects / SelfTest / TrickyTests . cpp \n  b / projects / SelfTest / TrickyTests . cpp \n \n # pragma clang diagnostic ignored \" - Wpadded \" \n # endif \n \n + # ifdef _MSC_VER \n + # pragma warning ( disable : 4702 ) / / Disable unreachable code warning for the last test \n + / / that is triggered when compiling as Win32 | Release \n + # endif \n + \n # include < stdio . h > \n \n # include \" catch . hpp \"", "msg": "Disable unreachable code warning for TrickyTests . cpp\n"}
{"diff": "a / src / main . cpp \n  b / src / main . cpp \n CBlock * CreateNewBlock ( CReserveKey & reservekey ) \n if ( ! tx . FetchInputs ( txdb , mapTestPoolTmp , false , true , mapInputs , fInvalid ) ) \n continue ; \n \n - int64 nFees = tx . GetValueIn ( mapInputs ) - tx . GetValueOut ( ) ; \n - if ( nFees < nMinFee ) \n + int64 nTxFees = tx . GetValueIn ( mapInputs ) - tx . GetValueOut ( ) ; \n + if ( nTxFees < nMinFee ) \n continue ; \n \n nTxSigOps + = tx . GetP2SHSigOpCount ( mapInputs ) ; \n CBlock * CreateNewBlock ( CReserveKey & reservekey ) \n nBlockSize + = nTxSize ; \n + + nBlockTx ; \n nBlockSigOps + = nTxSigOps ; \n + nFees + = nTxFees ; \n \n / / Add transactions that depend on this one to the priority queue \n uint256 hash = tx . GetHash ( ) ;", "msg": "CreateNewBlock was not adding in transaction fees .\n"}
{"diff": "a / src / mongo / tools / files . cpp \n  b / src / mongo / tools / files . cpp \n class Files : public Tool { \n if ( cmd = = \" list \" ) { \n BSONObjBuilder b ; \n if ( filename . size ( ) ) { \n - b . appendRegex ( \" filename \" , ( ( string ) \" ^ \" + pcrecpp : : RE : : QuoteMeta ( filename ) ) ) ; \n + b . appendRegex ( \" filename \" , ( string ) \" ^ \" + \n + pcrecpp : : RE : : QuoteMeta ( filename ) ) ; \n } \n \n display ( & g , b . obj ( ) ) ;", "msg": "Changes to address code review comments for SERVER - 4952\n"}
{"diff": "a / src / policy / fees . cpp \n  b / src / policy / fees . cpp \n double TxConfirmStats : : EstimateMedianVal ( int confTarget , double sufficientTxVal , \n failBucket . leftMempool = failNum ; \n } \n \n - LogPrint ( BCLog : : ESTIMATEFEE , \" FeeEst : % d % s % . 0f % % decay % . 5f : need feerate : % g from ( % g - % g ) % . 2f % % % . 1f / ( % . 1f + % d mem + % . 1f out ) Fail : ( % g - % g ) % . 2f % % % . 1f / ( % . 1f + % d mem + % . 1f out ) \\ n \" , \n + LogPrint ( BCLog : : ESTIMATEFEE , \" FeeEst : % d % s % . 0f % % decay % . 5f : feerate : % g from ( % g - % g ) % . 2f % % % . 1f / ( % . 1f % d mem % . 1f out ) Fail : ( % g - % g ) % . 2f % % % . 1f / ( % . 1f % d mem % . 1f out ) \\ n \" , \n confTarget , requireGreater ? \" > \" : \" < \" , 100 . 0 * successBreakPoint , decay , \n median , passBucket . start , passBucket . end , \n 100 * passBucket . withinTarget / ( passBucket . totalConfirmed + passBucket . inMempool + passBucket . leftMempool ) ,", "msg": "Clean up fee estimate debug printing\n"}
{"diff": "a / dlib / sockets / sockets_kernel_2 . cpp \n  b / dlib / sockets / sockets_kernel_2 . cpp \n \n # include < fcntl . h > \n # include \" . . / set . h \" \n # include < netinet / tcp . h > \n + # include < string . h >", "msg": "Add header needed in some contexts\n"}
{"diff": "a / stdlib / runtime / Casting . cpp \n  b / stdlib / runtime / Casting . cpp \n \n # include \" Private . h \" \n # include \" stddef . h \" \n \n + / / FIXME : Clang defines max_align_t in stddef . h since 3 . 6 . \n + / / Replace this with max_align_t when we can use it . \n + typedef long double swift_max_align_t ; \n + \n # include < dlfcn . h > \n \n # include < cstring > \n # include < mutex > \n # include < sstream > \n - # include < type_traits > \n - \n - / / FIXME : Clang defines max_align_t in stddef . h since 3 . 6 . \n - / / Replace this with max_align_t when we can use it . \n - typedef long double swift_max_align_t ; \n - \n - # ifdef __APPLE__ \n - static_assert ( std : : is_same < swift_max_align_t , std : : max_align_t > : : value , \n - \" types should match exactly on OS X and iOS \" ) ; \n - # endif \n \n using namespace swift ; \n using namespace metadataimpl ;", "msg": "Revert \" Runtime : add a static assertion that swift_max_align_t is correct for \"\n"}
{"diff": "a / src / qt / transactiontablemodel . cpp \n  b / src / qt / transactiontablemodel . cpp \n QString TransactionTableModel : : formatTxToAddress ( const TransactionRecord * wtx , b \n case TransactionRecord : : SendToIP : \n return QString : : fromStdString ( wtx - > address ) ; \n case TransactionRecord : : SendToSelf : \n - return QString ( ) ; \n case TransactionRecord : : Generated : \n default : \n - return QString ( ) ; \n + return tr ( \" ( n / a ) \" ) ; \n } \n } \n \n QVariant TransactionTableModel : : addressColor ( const TransactionRecord * wtx ) const \n if ( label . isEmpty ( ) ) \n return COLOR_BAREADDRESS ; \n } break ; \n + case TransactionRecord : : SendToSelf : \n + case TransactionRecord : : Generated : \n + return COLOR_BAREADDRESS ; \n default : \n break ; \n }", "msg": "show n / a for mined transactions ( and send to self ) instead of empty field\n"}
{"diff": "a / fdbclient / ReadYourWrites . actor . cpp \n  b / fdbclient / ReadYourWrites . actor . cpp \n void ReadYourWritesTransaction : : updateConflictMap ( KeyRef const & key , WriteMap : : \n / / it . skip ( key ) ; \n / / ASSERT ( it . beginKey ( ) < = key & & key < it . endKey ( ) ) ; \n if ( it . is_unmodified_range ( ) | | ( it . is_operation ( ) & & ! it . is_independent ( ) ) ) { \n - approximateSize + = key . expectedSize ( ) + sizeof ( KeyRangeRef ) ; \n + approximateSize + = 2 * key . expectedSize ( ) + 1 + sizeof ( KeyRangeRef ) ; \n readConflicts . insert ( singleKeyRange ( key , arena ) , true ) ; \n } \n }", "msg": "Update fdbclient / ReadYourWrites . actor . cpp\n"}
{"diff": "a / db / javajs . cpp \n  b / db / javajs . cpp \n using namespace boost : : filesystem ; \n \n # ifdef J_USE_OBJ \n # include \" jsobj . h \" \n + # if defined ( _WIN32 ) \n + # pragma message ( \" warning : including jsobj . h \" ) \n + # else \n # warning including jsobj . h \n # endif \n + # endif \n \n # include \" . . / grid / message . h \" \n # include \" db . h \"", "msg": "Use # pragma message rather than # warning in windows\n"}
{"diff": "a / modules / visual_script / visual_script_func_nodes . cpp \n  b / modules / visual_script / visual_script_func_nodes . cpp \n \n \n int VisualScriptFunctionCall : : get_output_sequence_port_count ( ) const { \n \n - if ( method_cache . flags & METHOD_FLAG_CONST ) \n + if ( method_cache . flags & METHOD_FLAG_CONST | | call_mode = = CALL_MODE_BASIC_TYPE ) \n return 0 ; \n else \n return 1 ; \n int VisualScriptFunctionCall : : get_output_sequence_port_count ( ) const { \n \n bool VisualScriptFunctionCall : : has_input_sequence_port ( ) const { \n \n - if ( method_cache . flags & METHOD_FLAG_CONST ) \n + if ( method_cache . flags & METHOD_FLAG_CONST | | call_mode = = CALL_MODE_BASIC_TYPE ) \n return false ; \n else \n return true ;", "msg": "Made basic call nodes unsequenced , since they are like gdscript and most return const .\n"}
{"diff": "a / src / input_common / gcadapter / gc_adapter . cpp \n  b / src / input_common / gcadapter / gc_adapter . cpp \n GCPadStatus Adapter : : GetPadStatus ( int port , const std : : array < u8 , 37 > & adapter_pa \n } \n \n void Adapter : : PadToState ( const GCPadStatus & pad , GCState & state ) { \n - for ( auto button : PadButtonArray ) { \n + for ( auto const & button : PadButtonArray ) { \n u16 button_value = static_cast < u16 > ( button ) ; \n state . buttons . insert_or_assign ( button_value , pad . button & button_value ) ; \n } \n bool Adapter : : CheckDeviceAccess ( libusb_device * device ) { \n } \n \n if ( desc . idVendor ! = 0x057e | | desc . idProduct ! = 0x0337 ) { \n - / / This isn \u2019 t the device we are looking for . \n + / / This isn\u00c2 \u2019 t the device we are looking for . \n return false ; \n } \n const int open_error = libusb_open ( device , & usb_adapter_handle ) ;", "msg": "const & to button in button array\n"}
{"diff": "a / plugins / net_plugin / net_plugin . cpp \n  b / plugins / net_plugin / net_plugin . cpp \n namespace eosio { \n \n block_id_type blk_id = bh . id ( ) ; \n if ( my_impl - > dispatcher - > have_block ( blk_id ) ) { \n + uint32_t blk_num = bh . block_num ( ) ; \n fc_dlog ( logger , \" canceling wait on $ { p } , already received block $ { num } \" , \n - ( \" p \" , peer_name ( ) ) ( \" num \" , block_header : : num_from_id ( blk_id ) ) ) ; \n - consecutive_rejected_blocks = 0 ; \n + ( \" p \" , peer_name ( ) ) ( \" num \" , blk_num ) ) ; \n + my_impl - > sync_master - > sync_recv_block ( shared_from_this ( ) , blk_id , blk_num ) ; \n cancel_wait ( ) ; \n \n pending_message_buffer . advance_read_ptr ( message_length ) ;", "msg": "Call sync_recv_block for already received block since accounting of blocks is required\n"}
{"diff": "a / dbms / src / Functions / FunctionsMiscellaneous . cpp \n  b / dbms / src / Functions / FunctionsMiscellaneous . cpp \n class FunctionMakeDictionary : public IFunction \n const auto & arg = block . getByPosition ( arg_num ) ; \n auto & res = block . getByPosition ( result ) ; \n auto column = res . type - > createColumn ( ) ; \n - column - > insertRangeFrom ( * arg . column , 0 , arg . column - > size ( ) ) ; \n + typeid_cast < DataTypeWithDictionary & > ( * column ) . insertRangeFromFullColumn ( * arg . column , 0 , arg . column - > size ( ) ) ; \n res . column = std : : move ( column ) ; \n } \n } ;", "msg": "Fixed ColumnWithDictionsry insert functions . Added insertFromFullColumn and insertRangeFromFullColumn .\n"}
{"diff": "a / src / idl_parser . cpp \n  b / src / idl_parser . cpp \n CheckedError Parser : : Next ( ) { \n cursor_ + + ; \n / / TODO : make nested . \n while ( * cursor_ ! = ' * ' | | cursor_ [ 1 ] ! = ' / ' ) { \n + if ( * cursor_ = = ' \\ n ' ) line_ + + ; \n if ( ! * cursor_ ) return Error ( \" end of file in comment \" ) ; \n cursor_ + + ; \n }", "msg": "Fixed line numbers being off in multi - line comments .\n"}
{"diff": "a / lib / IDE / CommentConversion . cpp \n  b / lib / IDE / CommentConversion . cpp \n struct CommentToXMLConverter { \n # include \" swift / Markup / SimpleFields . def \" \n \n void printDocument ( const Document * D ) { \n - llvm_unreachable ( \" Can ' t print an swift : : markup : : Document as XML directly \" ) ; \n + llvm_unreachable ( \" Can ' t print a swift : : markup : : Document as XML directly \" ) ; \n } \n \n void printBlockQuote ( const BlockQuote * BQ ) { \n break ; \n \n void printDocument ( const Document * D ) { \n / / FIXME : Why keep doing this ? \n - llvm_unreachable ( \" Can ' t print an swift : : markup : : Document as XML directly \" ) ; \n + llvm_unreachable ( \" Can ' t print a swift : : markup : : Document as XML directly \" ) ; \n } \n \n void printBlockQuote ( const BlockQuote * BQ ) {", "msg": "[ gardening ] Fix recently introduced typo : \" an swift \" \u2192 \" a swift \"\n"}
{"diff": "a / lib / Sema / TypeCheckProtocol . cpp \n  b / lib / Sema / TypeCheckProtocol . cpp \n static void diagnoseWitnessFixAccessLevel ( DiagnosticEngine & diags , \n if ( extAccess < requiredAccess ) { \n shouldMoveToAnotherExtension = true ; \n } else if ( extAccess = = requiredAccess ) { \n - auto declAttr = decl - > getAttrs ( ) . getAttribute < AccessControlAttr > ( ) ; \n - assert ( declAttr & & declAttr - > getAccess ( ) < requiredAccess & & \n - \" expect an explicitly specified access control level which is \" \n - \" less accessible than required . \" ) ; \n - ( void ) declAttr ; \n + assert ( decl - > getFormalAccess ( ) < requiredAccess & & \n + \" witness is accessible ? \" ) ; \n shouldUseDefaultAccess = true ; \n } \n }", "msg": "Relax an assert in witness access diagnostics\n"}
{"diff": "a / dbms / src / Interpreters / SystemLog . cpp \n  b / dbms / src / Interpreters / SystemLog . cpp \n std : : shared_ptr < TSystemLog > createSystemLog ( \n else \n { \n String partition_by = config . getString ( config_prefix + \" . partition_by \" , \" toYYYYMM ( event_date ) \" ) ; \n - engine = \" ENGINE = MergeTree PARTITION BY ( \" + partition_by + \" ) ORDER BY ( event_date , event_time ) SETTINGS index_granularity = 1024 \" ; \n + engine = \" ENGINE = MergeTree PARTITION BY ( \" + partition_by + \" ) ORDER BY ( event_date , event_time ) \" \n + \" SETTINGS index_granularity = 1024 , min_bytes_for_wide_part = 10485760 \" ; / / / Use polymorphic parts for log tables by default \n } \n \n size_t flush_interval_milliseconds = config . getUInt64 ( config_prefix + \" . flush_interval_milliseconds \" , DEFAULT_SYSTEM_LOG_FLUSH_INTERVAL_MILLISECONDS ) ;", "msg": "turn on polymorphic parts for log tables\n"}
{"diff": "a / lib / Frontend / CompilerInvocation . cpp \n  b / lib / Frontend / CompilerInvocation . cpp \n static bool ParseFrontendArgs ( FrontendOptions & Opts , ArgList & Args , \n return true ; \n } \n \n - if ( Args . hasArg ( OPT_parse_sil ) | | \n - ( Opts . InputFilenames . size ( ) = = 1 & & \n - llvm : : sys : : path : : extension ( Opts . InputFilenames [ 0 ] ) = = SIL_EXTENSION ) ) \n + bool TreatAsSIL = Args . hasArg ( OPT_parse_sil ) ; \n + if ( ! TreatAsSIL & & Opts . InputFilenames . size ( ) = = 1 ) { \n + / / If we have exactly one input filename , and its extension is \" sil \" , \n + / / treat the input as SIL . \n + StringRef Input ( Opts . InputFilenames [ 0 ] ) ; \n + TreatAsSIL = llvm : : sys : : path : : extension ( Input ) . endswith ( SIL_EXTENSION ) ; \n + } \n + \n + if ( TreatAsSIL ) \n Opts . InputKind = SourceFileKind : : SIL ; \n else if ( Args . hasArg ( OPT_parse_as_library ) ) \n Opts . InputKind = SourceFileKind : : Library ;", "msg": "[ frontend ] Fixed an issue with auto - detecting SIL input .\n"}
{"diff": "a / src / Common / Exception . cpp \n  b / src / Common / Exception . cpp \n namespace ErrorCodes \n \n / / / Aborts the process if error code is LOGICAL_ERROR . \n / / / Increments error codes statistics . \n - void handle_error_code ( const std : : string & msg , int code ) / / NOLINT \n + void handle_error_code ( [ [ maybe_unused ] ] const std : : string & msg , int code ) \n { \n / / In debug builds and builds with sanitizers , treat LOGICAL_ERROR as an assertion failure . \n / / Log the message before we fail .", "msg": "Add [ [ maybe_unused ] ] for msg parameter in handle_error_code .\n"}
{"diff": "a / folly / json . cpp \n  b / folly / json . cpp \n std : : string toJson ( dynamic const & dyn ) { \n std : : string toPrettyJson ( dynamic const & dyn ) { \n json : : serialization_opts opts ; \n opts . pretty_formatting = true ; \n + opts . sort_keys = true ; \n return json : : serialize ( dyn , opts ) ; \n }", "msg": "toPrettyJson ( ) sorts keys for deterministic output\n"}
{"diff": "a / arangod / Aql / TraversalNode . cpp \n  b / arangod / Aql / TraversalNode . cpp \n TraversalNode : : TraversalNode ( ExecutionPlan * plan , size_t id , \n _edgeColls . emplace_back ( std : : make_unique < aql : : Collection > ( \n n , _vocbase , TRI_TRANSACTION_READ ) ) ; \n } else { \n + _directions . emplace_back ( dir ) ; \n _edgeColls . emplace_back ( std : : make_unique < aql : : Collection > ( \n n , _vocbase , TRI_TRANSACTION_READ ) ) ; \n - _directions . emplace_back ( dir ) ; \n } \n } ; \n \n TraversalNode : : TraversalNode ( ExecutionPlan * plan , size_t id , \n names = c - > realNamesForRead ( ) ; \n } \n for ( auto const & name : names ) { \n - addEdgeColl ( name , baseDirection ) ; \n + addEdgeColl ( name , dir ) ; \n } \n } \n } else {", "msg": "Fixed creation of SmartCollections with correct directions .\n"}
{"diff": "a / xbmc / pvr / windows / GUIWindowPVRGuide . cpp \n  b / xbmc / pvr / windows / GUIWindowPVRGuide . cpp \n void CGUIWindowPVRGuide : : ResetObservers ( void ) \n \n void CGUIWindowPVRGuide : : Notify ( const Observable & obs , const ObservableMessage msg ) \n { \n - if ( msg = = ObservableMessageEpg | | ObservableMessageEpgContainer ) \n + if ( msg = = ObservableMessageEpg | | msg = = ObservableMessageEpgContainer ) \n { \n m_bUpdateRequired = true ;", "msg": "[ epg ] fix for wrong if condition in fix d83260197dee56d72e3c2c22602e986aba337c81\n"}
{"diff": "a / fdbclient / MultiVersionTransaction . actor . cpp \n  b / fdbclient / MultiVersionTransaction . actor . cpp \n void DLApi : : init ( ) { \n loadClientFunction ( & api - > transactionReset , lib , fdbCPath , \" fdb_transaction_reset \" ) ; \n loadClientFunction ( & api - > transactionCancel , lib , fdbCPath , \" fdb_transaction_cancel \" ) ; \n loadClientFunction ( & api - > transactionAddConflictRange , lib , fdbCPath , \" fdb_transaction_add_conflict_range \" ) ; \n - loadClientFunction ( & api - > transactionGetStorageByteSample , lib , fdbCPath , \" fdb_transaction_get_storage_byte_sample \" ) ; \n + loadClientFunction ( & api - > transactionGetStorageByteSample , lib , fdbCPath , \" fdb_transaction_get_storage_byte_sample \" , headerVersion > = 700 ) ; \n \n loadClientFunction ( & api - > futureGetInt64 , lib , fdbCPath , headerVersion > = 620 ? \" fdb_future_get_int64 \" : \" fdb_future_get_version \" ) ; \n loadClientFunction ( & api - > futureGetError , lib , fdbCPath , \" fdb_future_get_error \" ) ;", "msg": "Update fdbclient / MultiVersionTransaction . actor . cpp\n"}
{"diff": "a / lib / Sema / TypeCheckDeclOverride . cpp \n  b / lib / Sema / TypeCheckDeclOverride . cpp \n SmallVector < OverrideMatch , 2 > OverrideMatcher : : match ( \n if ( members . empty ( ) | | name ! = membersName ) { \n membersName = name ; \n members . clear ( ) ; \n + / / FIXME : This suggests we need to use TypeChecker ' s high - level lookup \n + / / entrypoints . But first we need one that supports additive qualified \n + / / lookup . \n + for ( auto * ctx : superContexts ) { \n + ctx - > synthesizeSemanticMembersIfNeeded ( membersName ) ; \n + } \n dc - > lookupQualified ( superContexts , membersName , \n NL_QualifiedDefault , members ) ; \n }", "msg": "Synthesize semantic members for override matching\n"}
{"diff": "a / folly / io / async / Request . cpp \n  b / folly / io / async / Request . cpp \n bool RequestContext : : hasContextData ( const std : : string & val ) const { \n } \n \n RequestData * RequestContext : : getContextData ( const std : : string & val ) { \n - return get_ref_default ( * data_ . rlock ( ) , val , nullptr ) . get ( ) ; \n + const std : : unique_ptr < RequestData > dflt { nullptr } ; \n + return get_ref_default ( * data_ . rlock ( ) , val , dflt ) . get ( ) ; \n } \n \n const RequestData * RequestContext : : getContextData ( \n const std : : string & val ) const { \n - return get_ref_default ( * data_ . rlock ( ) , val , nullptr ) . get ( ) ; \n + const std : : unique_ptr < RequestData > dflt { nullptr } ; \n + return get_ref_default ( * data_ . rlock ( ) , val , dflt ) . get ( ) ; \n } \n \n void RequestContext : : onSet ( ) {", "msg": "Avoid passing temporary to get_ref_default ( )\n"}
{"diff": "a / programs / cleos / main . cpp \n  b / programs / cleos / main . cpp \n chain : : action create_newaccount ( const name & creator , const name & newaccount , aut \n eosio : : chain : : newaccount { \n . creator = creator , \n . name = newaccount , \n - . owner = ! owner . which ( ) ? authority ( owner . get < public_key_type > ( ) ) : authority ( owner . get < permission_level > ( ) ) , \n - . active = ! active . which ( ) ? authority ( active . get < public_key_type > ( ) ) : authority ( active . get < permission_level > ( ) ) \n + . owner = owner . contains < public_key_type > ( ) ? authority ( owner . get < public_key_type > ( ) ) : authority ( owner . get < permission_level > ( ) ) , \n + . active = active . contains < public_key_type > ( ) ? authority ( active . get < public_key_type > ( ) ) : authority ( active . get < permission_level > ( ) ) \n } \n } ; \n }", "msg": "Check the type of given authority explicitly during account creation\n"}
{"diff": "a / src / core / hle / service / nvflinger / buffer_queue . cpp \n  b / src / core / hle / service / nvflinger / buffer_queue . cpp \n BufferQueue : : ~ BufferQueue ( ) = default ; \n void BufferQueue : : SetPreallocatedBuffer ( u32 slot , const IGBPBuffer & igbp_buffer ) { \n LOG_WARNING ( Service , \" Adding graphics buffer { } \" , slot ) ; \n \n - Buffer buffer { } ; \n - buffer . slot = slot ; \n - buffer . igbp_buffer = igbp_buffer ; \n - buffer . status = Buffer : : Status : : Free ; \n free_buffers . push_back ( slot ) ; \n + queue . push_back ( { \n + . slot = slot , \n + . status = Buffer : : Status : : Free , \n + . igbp_buffer = igbp_buffer , \n + } ) ; \n \n - queue . emplace_back ( buffer ) ; \n buffer_wait_event . writable - > Signal ( ) ; \n }", "msg": "buffer_queue : Make use of designated initializers\n"}
{"diff": "a / lib / AST / ProtocolConformance . cpp \n  b / lib / AST / ProtocolConformance . cpp \n ProtocolConformance : : subst ( Type substType , \n / / the underlying class type . \n auto targetClass = \n inheritedConformance - > getType ( ) - > getClassOrBoundGenericClass ( ) ; \n - auto superclassType = substType ; \n - while ( superclassType - > getClassOrBoundGenericClass ( ) ! = targetClass ) \n - superclassType = superclassType - > getSuperclass ( ) ; \n + auto superclassType = substType - > getSuperclassForDecl ( targetClass ) ; \n \n / / Substitute into the superclass . \n - newBase = inheritedConformance - > subst ( superclassType , subs , \n - conformances ) ; \n + newBase = inheritedConformance - > subst ( superclassType , subs , conformances ) ; \n } else { \n newBase = inheritedConformance ; \n }", "msg": "[ AST ] Use getSuperclassForDecl ( ) appropriately .\n"}
{"diff": "a / modules / imgcodecs / src / grfmt_tiff . cpp \n  b / modules / imgcodecs / src / grfmt_tiff . cpp \n bool TiffEncoder : : writeLibTiff ( const Mat & img , const std : : vector < int > & params ) \n | | ! TIFFSetField ( pTiffHandle , TIFFTAG_SAMPLESPERPIXEL , channels ) \n | | ! TIFFSetField ( pTiffHandle , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) \n | | ! TIFFSetField ( pTiffHandle , TIFFTAG_ROWSPERSTRIP , rowsPerStrip ) \n - | | ! TIFFSetField ( pTiffHandle , TIFFTAG_PREDICTOR , predictor ) \n + / / | | ! TIFFSetField ( pTiffHandle , TIFFTAG_PREDICTOR , predictor ) \n ) \n { \n TIFFClose ( pTiffHandle ) ; \n return false ; \n } \n \n + if ( compression ! = COMPRESSION_NONE & & ! TIFFSetField ( pTiffHandle , TIFFTAG_PREDICTOR , predictor ) ) \n + { \n + TIFFClose ( pTiffHandle ) ; \n + return false ; \n + } \n + \n / / row buffer , because TIFFWriteScanline modifies the original data ! \n size_t scanlineSize = TIFFScanlineSize ( pTiffHandle ) ; \n AutoBuffer < uchar > _buffer ( scanlineSize + 32 ) ;", "msg": "added support for uncompressed parameters to tiff image format as described here : expertland . net / question / b6o3n6p9a72341db823b48nl98m91dx8n1 / detail . html\n"}
{"diff": "a / lib / ClangImporter / ImportType . cpp \n  b / lib / ClangImporter / ImportType . cpp \n namespace { \n auto pointeeType = Impl . importType ( pointeeQualType , \n ImportTypeKind : : Normal ) ; \n \n - if ( ! pointeeType | | type - > isVoidPointerType ( ) ) { \n + / / If we can ' t represent the pointee in Swift , don ' t try to use a bridged \n + / / pointer type . \n + if ( ! pointeeType ) \n + return Type ( ) ; \n + \n + if ( type - > isVoidPointerType ( ) ) { \n / / Pointers to unmappable or void types map to C * VoidPointer . \n if ( pointeeQualType . isConstQualified ( ) ) \n return Impl . getNamedSwiftType ( Impl . getStdlibModule ( ) ,", "msg": "ClangImporter : Don ' t bridge pointers to forward - declared types .\n"}
{"diff": "a / lib / AST / ArchetypeBuilder . cpp \n  b / lib / AST / ArchetypeBuilder . cpp \n Type ArchetypeBuilder : : PotentialArchetype : : getTypeInContext ( \n ParentArchetype - > registerNestedType ( getName ( ) , arch ) ; \n } else { \n / / Create a top - level archetype . \n - arch = ArchetypeType : : getNew ( ctx , genericEnv , getName ( ) , Protos , \n + Identifier name = \n + genericParams [ getGenericParamKey ( ) . findIndexIn ( genericParams ) ] - > getName ( ) ; \n + arch = ArchetypeType : : getNew ( ctx , genericEnv , name , Protos , \n superclass , layout ) ; \n \n / / Register the archetype with the generic environment .", "msg": "[ Archetype builder ] Use the names of the given generic parameters\n"}
{"diff": "a / src / loglistwidget . cpp \n  b / src / loglistwidget . cpp \n void LogListWidget : : keyPressEvent ( QKeyEvent * event ) \n \n void LogListWidget : : appendLine ( const QString & line ) \n { \n - QListWidgetItem * item = new QListWidgetItem ( this ) ; \n + QListWidgetItem * item = new QListWidgetItem ; \n / / We need to use QLabel here to support rich text \n QLabel * lbl = new QLabel ( line ) ; \n lbl - > setContentsMargins ( 4 , 2 , 4 , 2 ) ;", "msg": "Prevent log window buffer from filling up ( Closes )\n"}
{"diff": "a / lib / Sema / TypeCheckDecl . cpp \n  b / lib / Sema / TypeCheckDecl . cpp \n class DeclChecker : public DeclVisitor < DeclChecker > { \n } \n \n / / Diagnose any abstract constructors from our superclass that have \n - / / not been overridden . \n + / / not been overridden or inherited . \n bool diagnosed = false ; \n for ( auto superclassMember : TC . lookupConstructors ( superclassTy , CD ) ) { \n / / We only care about abstract constructors . \n class DeclChecker : public DeclVisitor < DeclChecker > { \n if ( overriddenCtors . count ( superclassCtor ) > 0 ) \n continue ; \n \n + / / If the superclass constructor is a complete object initializer \n + / / that is inherited into the current class , it ' s okay . \n + if ( superclassCtor - > isCompleteObjectInit ( ) & & \n + CD - > inheritsSuperclassInitializers ( & TC ) ) \n + continue ; \n + \n / / Complain that we don ' t have an overriding constructor . \n if ( ! diagnosed ) { \n TC . diagnose ( CD , diag : : abstract_incomplete_implementation ,", "msg": "A complete object initializer can satisfy an @ abstract initializer requirement for a subclass .\n"}
{"diff": "a / modules / gdscript / gd_editor . cpp \n  b / modules / gdscript / gd_editor . cpp \n String GDScriptLanguage : : make_function ( const String & p_class , const String & p_na \n } \n s + = \" \" ; \n } \n - s + = \" ) : \\ n \\ tpass # replace with function body \\ n \" ; \n + s + = \" ) : \\ n \" + _get_indentation ( ) + \" pass # replace with function body \\ n \" ; \n \n return s ; \n }", "msg": "Fixed signal connection dialog ignoring indentation settings when creating a function .\n"}
{"diff": "a / drivers / gles2 / rasterizer_storage_gles2 . cpp \n  b / drivers / gles2 / rasterizer_storage_gles2 . cpp \n void RasterizerStorageGLES2 : : _render_target_allocate ( RenderTarget * rt ) { \n \n bool used_depth = false ; \n if ( j = = 0 & & i = = 0 ) { / / use always \n - glFramebufferTexture2D ( GL_FRAMEBUFFER , GL_DEPTH_ATTACHMENT , GL_TEXTURE_2D , rt - > depth , 0 ) ; \n + if ( config . support_depth_texture ) { \n + glFramebufferTexture2D ( GL_FRAMEBUFFER , GL_DEPTH_ATTACHMENT , GL_TEXTURE_2D , rt - > depth , 0 ) ; \n + } else { \n + glFramebufferRenderbuffer ( GL_FRAMEBUFFER , GL_DEPTH_ATTACHMENT , GL_RENDERBUFFER , rt - > depth ) ; \n + } \n used_depth = true ; \n }", "msg": "Use renderbuffer depth for post - process buffers when appropriate\n"}
{"diff": "a / xbmc / interfaces / legacy / File . cpp \n  b / xbmc / interfaces / legacy / File . cpp \n namespace XBMCAddon \n bool File : : write ( XbmcCommons : : Buffer & buffer ) \n { \n DelayedCallGuard dg ( languageHook ) ; \n - unsigned long totalBytesWritten = 0 ; \n while ( buffer . remaining ( ) > 0 ) \n { \n int bytesWritten = file - > Write ( buffer . curPosition ( ) , buffer . remaining ( ) ) ; \n - totalBytesWritten + = bytesWritten ; \n if ( bytesWritten = = 0 ) / / this could be a failure ( see HDFile , and XFileUtils ) or \n / / it could mean something else when a negative number means an error \n / / ( see CCurlFile ) . There is no consistency so we can only assume we ' re", "msg": "minor change and clarification to the File . write return value .\n"}
{"diff": "a / src / bitcoinrpc . cpp \n  b / src / bitcoinrpc . cpp \n Value addmultisigaddress ( const Array & params , bool fHelp ) \n if ( address . IsScript ( ) ) \n throw runtime_error ( \n strprintf ( \" % s is a pay - to - script address \" , ks . c_str ( ) ) ) ; \n - if ( ! pwalletMain - > GetKey ( address , pubkeys [ i ] ) ) \n + std : : vector < unsigned char > vchPubKey ; \n + if ( ! pwalletMain - > GetPubKey ( address , vchPubKey ) ) \n throw runtime_error ( \n strprintf ( \" no full public key for address % s \" , ks . c_str ( ) ) ) ; \n + if ( vchPubKey . empty ( ) | | ! pubkeys [ i ] . SetPubKey ( vchPubKey ) ) \n + throw runtime_error ( \" Invalid public key : \" + ks ) ; \n } \n \n / / Case 2 : hex public key", "msg": "Fixed addmultisigaddress if looking up public keys from locked wallets .\n"}
{"diff": "a / scene / 3d / camera . cpp \n  b / scene / 3d / camera . cpp \n Vector3 Camera : : project_position ( const Point2 & p_point , float p_z_depth ) const { \n \n ERR_FAIL_COND_V_MSG ( ! is_inside_tree ( ) , Vector3 ( ) , \" Camera is not inside scene . \" ) ; \n \n - if ( p_z_depth = = 0 ) { \n + if ( p_z_depth = = 0 & & mode ! = PROJECTION_ORTHOGONAL ) { \n return get_global_transform ( ) . origin ; \n } \n - \n Size2 viewport_size = get_viewport ( ) - > get_visible_rect ( ) . size ; \n \n CameraMatrix cm ;", "msg": "Update Camera . project_position to not return get_global_transform ( ) . origin if projection mode is orthogonal\n"}
{"diff": "a / platform / windows / os_windows . cpp \n  b / platform / windows / os_windows . cpp \n LRESULT OS_Windows : : WndProc ( HWND hWnd , UINT uMsg , WPARAM wParam , LPARAM lParam ) \n case WM_MOUSEWHEEL : \n case WM_MOUSEHWHEEL : \n case WM_LBUTTONDBLCLK : \n - case WM_RBUTTONDBLCLK : \n + case WM_MBUTTONDBLCLK case WM_RBUTTONDBLCLK : \n / * case WM_XBUTTONDOWN : \n case WM_XBUTTONUP : * / { \n \n LRESULT OS_Windows : : WndProc ( HWND hWnd , UINT uMsg , WPARAM wParam , LPARAM lParam ) \n mb - > set_button_index ( 2 ) ; \n mb - > set_doubleclick ( true ) ; \n } break ; \n + case WM_MBUTTONDBLCLK : { \n + \n + mb - > set_pressed ( true ) ; \n + mb - > set_button_index ( 3 ) ; \n + mb - > set_doubleclick ( true ) ; \n + } break ; \n case WM_MOUSEWHEEL : { \n \n mb - > set_pressed ( true ) ;", "msg": "Added middle button doubleclick , fixes\n"}
{"diff": "similarity index 99 % \n rename from folly / stats / detail / test / RadixSortTest . cpp \n rename to folly / stats / detail / test / DoubleRadixSortTest . cpp \n  a / folly / stats / detail / test / RadixSortTest . cpp \n  b / folly / stats / detail / test / DoubleRadixSortTest . cpp \n \n * limitations under the License . \n * / \n \n + # include < folly / stats / detail / DoubleRadixSort . h > \n + \n # include < folly / Random . h > \n # include < folly / portability / GTest . h > \n - # include < folly / stats / detail / DoubleRadixSort . h > \n \n using namespace folly : : detail ;", "msg": "Match DoubleRadixSort test name to file name\n"}
{"diff": "a / src / core / hle / service / ldr / ldr . cpp \n  b / src / core / hle / service / ldr / ldr . cpp \n class RelocatableObject final : public ServiceFramework < RelocatableObject > { \n using SHA256Hash = std : : array < u8 , 0x20 > ; \n \n struct NROHeader { \n - u32_le entrypoint_insn ; \n + INSERT_PADDING_WORDS ( 1 ) ; \n u32_le mod_offset ; \n INSERT_PADDING_WORDS ( 2 ) ; \n u32_le magic ; \n - INSERT_PADDING_WORDS ( 1 ) ; \n + u32_le version ; \n u32_le nro_size ; \n - INSERT_PADDING_WORDS ( 1 ) ; \n + u32_le flags ; \n u32_le text_offset ; \n u32_le text_size ; \n u32_le ro_offset ;", "msg": "service / ldr : Amend layout of the NRO header\n"}
{"diff": "a / unittests / Basic / DiverseStackTest . cpp \n  b / unittests / Basic / DiverseStackTest . cpp \n struct ThreeByteType : ParentType { \n \n struct RandomValueGenerator { \n std : : mt19937 gen ; \n - std : : uniform_int_distribution < uint8_t > randomEightBitValueGenerator ; \n + std : : uniform_int_distribution < int > randomEightBitValueGenerator { \n + 0 , std : : numeric_limits < uint8_t > : : max ( ) } ; \n std : : uniform_int_distribution < uint16_t > randomSixteenBitValueGenerator ; \n \n / / Randomly generated bits . This is frozen to ensure that the test doesn ' t", "msg": "Don ' t use a uint8_t random distruction in DiverseStack unit tests\n"}
{"diff": "a / Source / SGDLib / SGD . cpp \n  b / Source / SGDLib / SGD . cpp \n void SGD < ElemType > : : TrainOrAdaptModel ( int startEpoch , ComputationNetworkPtr net , \n m_lastFinishedEpochTrainLoss = epochCriterion . Average ( ) ; \n for ( size_t j = 0 ; j < epochEvalErrors . size ( ) ; j + + ) \n epochEvalErrors [ j ] . LogCriterion ( evaluationNodes [ j ] - > NodeName ( ) ) ; \n - fprintf ( stderr , \" totalSamplesSeen = % d ; learningRatePerSample = % . 8g ; epochTime = % . 6gs \\ n \" , ( int ) totalTrainingSamplesSeen , learnRatePerSample , epochTime ) ; \n + fprintf ( stderr , \" totalSamplesSeen = % zu ; learningRatePerSample = % . 8g ; epochTime = % . 6gs \\ n \" , totalTrainingSamplesSeen , learnRatePerSample , epochTime ) ; \n # if 0 \n / / TODO : This was only printed if > 1 eval criterion . Why ? Needed ? \n LOGPRINTF ( stderr , \" Finished Epoch [ % 2d of % d ] : Criterion Node [ % ls ] Per Sample = % . 8g \\ n \" ,", "msg": "' totalSamplesSeen ' cast as Int64 instead of Int32 to avoid overflow\n"}
{"diff": "a / arangod / Aql / OptimizerRules . cpp \n  b / arangod / Aql / OptimizerRules . cpp \n class FilterToEnumCollFinder : public WalkerWorker < ExecutionNode > { \n / / TODO : who is going to free _ranges ? ? \n } ; \n \n + ~ FilterToEnumCollFinder ( ) { \n + delete _ranges ; \n + } \n + \n bool before ( ExecutionNode * en ) { \n _canThrow = ( _canThrow | | en - > canThrow ( ) ) ; / / can any node walked over throw ?", "msg": "Add a destructor to delete _ranges in FilterToEnumCollFinder .\n"}
{"diff": "a / scene / resources / style_box . cpp \n  b / scene / resources / style_box . cpp \n void StyleBoxFlat : : _bind_methods ( ) { \n \n ADD_GROUP ( \" Shadow \" , \" shadow_ \" ) ; \n ADD_PROPERTY ( PropertyInfo ( Variant : : COLOR , \" shadow_color \" ) , \" set_shadow_color \" , \" get_shadow_color \" ) ; \n - ADD_PROPERTY ( PropertyInfo ( Variant : : INT , \" shadow_size \" ) , \" set_shadow_size \" , \" get_shadow_size \" ) ; \n + ADD_PROPERTY ( PropertyInfo ( Variant : : INT , \" shadow_size \" , PROPERTY_HINT_RANGE , \" 0 , 100 , 1 , or_greater \" ) , \" set_shadow_size \" , \" get_shadow_size \" ) ; \n ADD_PROPERTY ( PropertyInfo ( Variant : : VECTOR2 , \" shadow_offset \" ) , \" set_shadow_offset \" , \" get_shadow_offset \" ) ; \n \n ADD_GROUP ( \" Anti Aliasing \" , \" anti_aliasing_ \" ) ;", "msg": "Add a property hint to StyleBoxFlat ` shadow_size ` for editor usability\n"}
{"diff": "a / s / chunk . cpp \n  b / s / chunk . cpp \n namespace mongo { \n \n fromconn . done ( ) ; \n \n - if ( worked ) { \n - _manager - > _reload ( ) ; \n - return true ; \n - } \n + / / if succeeded , needs to reload to pick up the new location \n + / / if failed , mongos may be stale \n + / / reload is excessive here as the failure could be simply because collection metadata is taken \n + _manager - > _reload ( ) ; \n \n - return false ; \n + return worked ; \n } \n \n bool Chunk : : splitIfShould ( long dataWritten ) {", "msg": "a failure in migrate can be because of chunk boundaries being stale\n"}
{"diff": "a / Code / CryEngine / CryAction / EntityContainers / FlowEntityContainerNodes . cpp \n  b / Code / CryEngine / CryAction / EntityContainers / FlowEntityContainerNodes . cpp \n class CFlowNode_EntityContainerContMgr_QueryIsInContainer : public CFlowBaseNode \n { \n static const SInputPortConfig inputs [ ] = \n { \n - InputPortConfig_AnyType ( \" DoQuery \" , _HELP ( \" Checks if the given Entity ID belonga to the selected container \" ) ) , \n - InputPortConfig < EntityId > ( \" EntityId \" , 0 , _HELP ( \" Entity ID to check \" ) ) , \n + InputPortConfig_AnyType ( \" DoQuery \" , _HELP ( \" Checks if the given Entity ID belongs to the selected container \" ) ) , \n + InputPortConfig < EntityId > ( \" Id \" , 0 , _HELP ( \" Entity ID to check \" ) ) , \n InputPortConfig < bool > ( \" AutomaticCheck \" , false , _HELP ( \" If True , the node will automatically fire its outputs if the selected entity is added / removed to the given container \" ) ) , \n { 0 } \n } ;", "msg": "! B ( CE - 13123 ) ( Flowgraph ) Multiple EntityInfo nodes cannot be attached to the QueryIsInContainer node\n"}
{"diff": "a / arangod / RestHandler / RestVocbaseBaseHandler . cpp \n  b / arangod / RestHandler / RestVocbaseBaseHandler . cpp \n void RestVocbaseBaseHandler : : generateNotModified ( TRI_voc_rid_t rid ) { \n / / / @ brief generates next entry from a result set \n / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / \n \n - void RestVocbaseBaseHandler : : generateDocument ( VPackSlice const & document , \n + void RestVocbaseBaseHandler : : generateDocument ( VPackSlice const & input , \n bool generateBody , \n VPackOptions const * options ) { \n + VPackSlice document = input . resolveExternal ( ) ; \n std : : string rev ; \n if ( document . isObject ( ) ) { \n rev = VelocyPackHelper : : getStringValue ( document , TRI_VOC_ATTRIBUTE_REV , \" \" ) ;", "msg": "Generate document in rest handler now works with externals\n"}
{"diff": "a / editor / import_dock . cpp \n  b / editor / import_dock . cpp \n void ImportDock : : _reimport_attempt ( ) { \n void ImportDock : : _reimport_and_restart ( ) { \n \n EditorNode : : get_singleton ( ) - > save_all_scenes ( ) ; \n + EditorResourcePreview : : get_singleton ( ) - > stop ( ) ; / / dont try to re - create previews \n _reimport ( ) ; \n EditorNode : : get_singleton ( ) - > restart_editor ( ) ; \n }", "msg": "Stop preview generator before reimporting resources with different type .\n"}
{"diff": "a / libraries / ESP8266WiFi / src / ESP8266WiFiAP . cpp \n  b / libraries / ESP8266WiFi / src / ESP8266WiFiAP . cpp \n bool ESP8266WiFiAPClass : : softAP ( const char * ssid , const char * passphrase , int ch \n return false ; \n } \n \n - if ( ! ssid | | * ssid = = 0 | | strlen ( ssid ) > 31 ) { \n + if ( ! ssid | | strlen ( ssid ) = = 0 | | strlen ( ssid ) > 31 ) { \n / / fail SSID too long or missing ! \n DEBUG_WIFI ( \" [ AP ] SSID too long or missing ! \\ n \" ) ; \n return false ; \n } \n \n - if ( passphrase & & ( strlen ( passphrase ) > 63 | | strlen ( passphrase ) < 8 ) ) { \n + if ( passphrase & & strlen ( passphrase ) > 0 & & ( strlen ( passphrase ) > 63 | | strlen ( passphrase ) < 8 ) ) { \n / / fail passphrase to long or short ! \n DEBUG_WIFI ( \" [ AP ] fail passphrase to long or short ! \\ n \" ) ; \n return false ;", "msg": "Re - enable old behaviour if passphrase string is empty\n"}
{"diff": "a / xbmc / interfaces / json - rpc / AudioLibrary . cpp \n  b / xbmc / interfaces / json - rpc / AudioLibrary . cpp \n JSONRPC_STATUS CAudioLibrary : : GetArtistDetails ( const CStdString & method , ITransp \n param [ \" properties \" ] = CVariant ( CVariant : : VariantTypeArray ) ; \n param [ \" properties \" ] . append ( \" artist \" ) ; \n \n - HandleFileItem ( \" artistid \" , false , \" artistdetails \" , items [ 0 ] , parameterObject , param [ \" properties \" ] , result , false ) ; \n + HandleFileItem ( \" artistid \" , false , \" artistdetails \" , items [ 0 ] , param , param [ \" properties \" ] , result , false ) ; \n return OK ; \n }", "msg": "fixed GetArtistDetails to return artist\n"}
{"diff": "a / src / mongo / db / repl / rs_rollback . cpp \n  b / src / mongo / db / repl / rs_rollback . cpp \n \n \n # include \" mongo / pch . h \" \n \n + # include \" mongo / db / auth / authorization_manager . h \" \n + # include \" mongo / db / auth / authorization_manager_global . h \" \n # include \" mongo / db / client . h \" \n # include \" mongo / db / cloner . h \" \n # include \" mongo / db / ops / update . h \" \n namespace mongo { \n / / todo : fatal error if this throws ? \n oplogDetails - > cappedTruncateAfter ( rsoplog , h . commonPointOurDiskloc , false ) ; \n \n + Status status = getGlobalAuthorizationManager ( ) - > initialize ( ) ; \n + if ( ! status . isOK ( ) ) { \n + warning ( ) < < \" Failed to reinitialize auth data after rollback : \" < < status ; \n + warn = true ; \n + } \n + \n / * reset cached lastoptimewritten and h value * / \n loadLastOpTimeWritten ( ) ;", "msg": "SERVER - 9516 Reinitialize user and role data on replicaset rollback .\n"}
{"diff": "a / xbmc / GUIDialogAddonSettings . cpp \n  b / xbmc / GUIDialogAddonSettings . cpp \n \n # include \" Settings . h \" \n # include \" GUIInfoManager . h \" \n # include \" GUIDialogSelect . h \" \n + # include \" utils / log . h \" \n \n using namespace std ; \n using namespace ADDON ; \n void CGUIDialogAddonSettings : : CreateControls ( ) \n \n setting = setting - > NextSiblingElement ( \" setting \" ) ; \n controlId + + ; \n + if ( controlId > = CONTROL_START_SECTION ) \n + { \n + CLog : : Log ( LOGERROR , \" % s - cannot have more than % d controls per category - simplify your addon ! \" , __FUNCTION__ , CONTROL_START_SECTION - CONTROL_START_SETTING ) ; \n + break ; \n + } \n } \n EnableControls ( ) ; \n }", "msg": "fixed : - Disallow more than 100 settings per category from addons .\n"}
{"diff": "a / xbmc / FileSystem / FileDAAP . cpp \n  b / xbmc / FileSystem / FileDAAP . cpp \n int64_t CFileDAAP : : Seek ( int64_t iFilePosition , int iWhence ) \n CSingleLock lock ( g_DaapClient ) ; \n \n if ( iWhence = = SEEK_POSSIBLE ) \n - return m_curl . Seek ( iFilePosition , iWhence ) ; \n + return 1 ; / / m_curl . Seek ( iFilePosition , iWhence ) ; \n \n int requestid = + + m_thisHost - > request_id ;", "msg": "changed : assume daap is seekable , asfar as i know the servers always are .\n"}
{"diff": "a / lib / SILOptimizer / IPO / EagerSpecializer . cpp \n  b / lib / SILOptimizer / IPO / EagerSpecializer . cpp \n static void addReturnValueImpl ( SILBasicBlock * RetBB , SILBasicBlock * NewRetBB , \n assert ( isa < ReturnInst > ( RetInst ) | | isa < ThrowInst > ( RetInst ) & & \n \" expected a properly terminated return or throw block \" ) ; \n assert ( RetInst - > getOperand ( 0 ) - > getType ( ) = = NewRetVal - > getType ( ) & & \n - \" Mistmatched return type \" ) ; \n + \" Mismatched return type \" ) ; \n SILBasicBlock * MergedBB = RetBB ; \n \n / / Split the return block if it is nontrivial .", "msg": "[ gardening ] Fix recently introduced typo : \" mistmatched \" \u2192 \" mismatched \"\n"}
{"diff": "a / src / main . cpp \n  b / src / main . cpp \n bool static ProcessMessage ( CNode * pfrom , string strCommand , CDataStream & vRecv ) \n CInv inv ( MSG_TX , tx . GetHash ( ) ) ; \n pfrom - > AddInventoryKnown ( inv ) ; \n \n - / / Truncate messages to the size of the tx in them \n - unsigned int nSize = : : GetSerializeSize ( tx , SER_NETWORK , PROTOCOL_VERSION ) ; \n - unsigned int oldSize = vMsg . size ( ) ; \n - if ( nSize < oldSize ) { \n - vMsg . resize ( nSize ) ; \n - printf ( \" truncating oversized TX % s ( % u - > % u ) \\ n \" , \n - tx . GetHash ( ) . ToString ( ) . c_str ( ) , \n - oldSize , nSize ) ; \n - } \n - \n bool fMissingInputs = false ; \n CValidationState state ; \n if ( mempool . accept ( state , tx , true , & fMissingInputs ) )", "msg": "Revert \" Truncate oversize ' tx ' messages before relaying / storing . \"\n"}
{"diff": "a / xbmc / cores / dvdplayer / DVDPlayer . cpp \n  b / xbmc / cores / dvdplayer / DVDPlayer . cpp \n bool CDVDPlayer : : GetCurrentSubtitle ( CStdString & strSubtitle ) \n { \n double pts = m_clock . GetClock ( ) + m_State . time_offset ; \n \n - if ( m_pInputStream & & m_pInputStream - > IsStreamType ( DVDSTREAM_TYPE_DVD ) & & m_CurrentSubtitle . source ! = STREAM_SOURCE_TEXT ) \n + if ( m_pInputStream & & m_pInputStream - > IsStreamType ( DVDSTREAM_TYPE_DVD ) & & m_CurrentSubtitle . source ! = STREAM_SOURCE_TEXT & & m_CurrentSubtitle . source ! = STREAM_SOURCE_DEMUX_SUB ) \n return false ; \n \n m_dvdPlayerSubtitle . GetCurrentSubtitle ( strSubtitle , pts - m_dvdPlayerVideo . GetSubtitleDelay ( ) ) ;", "msg": "allow external . sub subtitles next to text - based ones\n"}
{"diff": "a / xbmc / utils / TuxBoxUtil . cpp \n  b / xbmc / utils / TuxBoxUtil . cpp \n bool CTuxBoxUtil : : GetHttpXML ( CURL url , CStdString strRequestType ) \n CXBMCTinyXML doc ; \n TiXmlElement * XMLRoot = NULL ; \n strTmp . Replace ( \" > < / \" , \" > - < / \" ) ; / / FILL EMPTY ELEMENTS WITH \" - \" ! \n - doc . Parse ( strTmp ) ; \n + doc . Parse ( strTmp , http . GetServerReportedCharset ( ) ) ; \n strTmp . Empty ( ) ; \n \n XMLRoot = doc . RootElement ( ) ;", "msg": "TuxBoxUtil : use charset reported by http server\n"}
{"diff": "a / modules / bullet / space_bullet . cpp \n  b / modules / bullet / space_bullet . cpp \n bool SpaceBullet : : test_body_motion ( RigidBodyBullet * p_body , const Transform & p_f \n } else { \n if ( ! l_has_penetration ) \n break ; \n + else \n + has_penetration = true ; \n } \n } \n }", "msg": "Added return true o collide when no rusult is NULL\n"}
{"diff": "a / hphp / runtime / vm / jit / fixup . cpp \n  b / hphp / runtime / vm / jit / fixup . cpp \n union FixupEntry { \n IndirectFixup indirect ; \n } ; \n \n - TreadHashMap < uint32_t , FixupEntry , std : : hash < uint32_t > > s_fixups { kInitCapac } ; \n + struct FixupHash { \n + size_t operator ( ) ( uint32_t k ) const { \n + return hash_int64 ( k ) ; \n + } \n + } ; \n + \n + TreadHashMap < uint32_t , FixupEntry , FixupHash > s_fixups { kInitCapac } ; \n \n PC pc ( const ActRec * / * ar * / , const Func * f , const Fixup & fixup ) { \n assertx ( f ) ;", "msg": "Use hash_int64 in the Fixup TreadHashMap\n"}
{"diff": "a / src / brpc / controller . cpp \n  b / src / brpc / controller . cpp \n void Controller : : EndRPC ( const CompletionInfo & info ) { \n } \n if ( _stream_creator ) { \n _stream_creator - > DestroyStreamCreator ( this ) ; \n + _stream_creator = NULL ; \n } \n / / Clear _error_text when the call succeeded , otherwise a successful \n / / call with non - empty ErrorText may confuse user .", "msg": "set _stream_creator to NULL after DestroyStreamCreator\n"}
{"diff": "a / src / main . cpp \n  b / src / main . cpp \n bool static ProcessMessage ( CNode * pfrom , string strCommand , CDataStream & vRecv , \n \n if ( ! ( pfrom - > GetLocalServices ( ) & NODE_BLOOM ) & & \n ( strCommand = = NetMsgType : : FILTERLOAD | | \n - strCommand = = NetMsgType : : FILTERADD | | \n - strCommand = = NetMsgType : : FILTERCLEAR ) ) \n + strCommand = = NetMsgType : : FILTERADD ) ) \n { \n if ( pfrom - > nVersion > = NO_BLOOM_VERSION ) { \n LOCK ( cs_main ) ; \n bool static ProcessMessage ( CNode * pfrom , string strCommand , CDataStream & vRecv , \n else if ( strCommand = = NetMsgType : : FILTERCLEAR ) \n { \n LOCK ( pfrom - > cs_filter ) ; \n - delete pfrom - > pfilter ; \n - pfrom - > pfilter = new CBloomFilter ( ) ; \n + if ( pfrom - > GetLocalServices ( ) & NODE_BLOOM ) { \n + delete pfrom - > pfilter ; \n + pfrom - > pfilter = new CBloomFilter ( ) ; \n + } \n pfrom - > fRelayTxes = true ; \n }", "msg": "Merge : Allow filterclear messages for enabling TX relay only .\n"}
{"diff": "a / fdbclient / ManagementAPI . actor . cpp \n  b / fdbclient / ManagementAPI . actor . cpp \n std : : map < std : : string , std : : string > configForToken ( std : : string const & mode ) { \n \n if ( storeType . present ( ) ) { \n out [ p + \" log_engine \" ] = format ( \" % d \" , logType . get ( ) . operator KeyValueStoreType : : StoreType ( ) ) ; \n - out [ p + \" storage_engine \" ] = format ( \" % d \" , storeType . get ( ) . operator KeyValueStoreType : : StoreType ( ) ) ; \n + out [ p + \" storage_engine \" ] = format ( \" % d \" , KeyValueStoreType : : StoreType ( storeType . get ( ) ) ) ; \n return out ; \n }", "msg": "Use functional cast instead of explicit operator call\n"}
{"diff": "a / s / strategy_shard . cpp \n  b / s / strategy_shard . cpp \n namespace mongo { \n } \n \n void _insert ( Request & r , DbMessage & d , ChunkManagerPtr manager ) { \n - const int flags = d . reservedField ( ) ; \n + const int flags = d . reservedField ( ) | InsertOption_ContinueOnError ; / / ContinueOnError is always on when using sharding . \n map < ChunkPtr , vector < BSONObj > > insertsForChunk ; / / Group bulk insert for appropriate shards \n try { \n while ( d . moreJSObjs ( ) ) {", "msg": "Send ContinueOnError flag for all bulk inserts when using sharding .\n"}
{"diff": "a / test / src / unit - pointer_access . cpp \n  b / test / src / unit - pointer_access . cpp \n TEST_CASE ( \" pointer access \" ) \n \n const test_type * p2 = value . get_ptr < const test_type * > ( ) ; \n CHECK ( p1 = = value . get_ptr < const test_type * > ( ) ) ; \n - / / CHECK ( * p2 = = value . get < test_type > ( ) ) ; \n + CHECK ( * p2 = = value . get < test_type > ( ) ) ; \n \n const test_type * const p3 = value . get_ptr < const test_type * const > ( ) ; \n CHECK ( p1 = = value . get_ptr < const test_type * const > ( ) ) ; \n - / / CHECK ( * p3 = = value . get < test_type > ( ) ) ; \n + CHECK ( * p3 = = value . get < test_type > ( ) ) ; \n \n / / check if null pointers are returned correctly \n CHECK ( value . get_ptr < const json : : object_t * > ( ) = = nullptr ) ;", "msg": ": white_check_mark : re - added test\n"}
{"diff": "a / src / MainWindow . cpp \n  b / src / MainWindow . cpp \n void MainWindow : : switchToBrowseDataTab ( ) \n QString tableToBrowse = ui - > dbTreeWidget - > model ( ) - > data ( ui - > dbTreeWidget - > currentIndex ( ) . sibling ( ui - > dbTreeWidget - > currentIndex ( ) . row ( ) , 0 ) ) . toString ( ) ; \n \n ui - > mainTab - > setCurrentIndex ( 1 ) ; \n - ui - > comboBrowseTable - > setCurrentText ( tableToBrowse ) ; \n - ui - > comboBrowseTable - > activated ( tableToBrowse ) ; \n + ui - > comboBrowseTable - > setCurrentIndex ( ui - > comboBrowseTable - > findText ( tableToBrowse ) ) ; \n + populateTable ( tableToBrowse ) ; \n }", "msg": "Fix Qt4 build broken in dd8dd4852d97a92d6f9772dc788aaf1591d0ff19\n"}
{"diff": "a / core / variant_call . cpp \n  b / core / variant_call . cpp \n void register_variant_methods ( ) { \n _VariantCall : : add_variant_constant ( Variant : : TRANSFORM , \" IDENTITY \" , identity_transform ) ; \n transform_x . set ( - 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ) ; \n _VariantCall : : add_variant_constant ( Variant : : TRANSFORM , \" FLIP_X \" , transform_x ) ; \n - transform_x . set ( 1 , 0 , 0 , 0 , - 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ) ; \n + transform_y . set ( 1 , 0 , 0 , 0 , - 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ) ; \n _VariantCall : : add_variant_constant ( Variant : : TRANSFORM , \" FLIP_Y \" , transform_y ) ; \n - transform_x . set ( 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , - 1 , 0 , 0 , 0 ) ; \n + transform_z . set ( 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , - 1 , 0 , 0 , 0 ) ; \n _VariantCall : : add_variant_constant ( Variant : : TRANSFORM , \" FLIP_Z \" , transform_z ) ; \n \n _VariantCall : : add_variant_constant ( Variant : : PLANE , \" PLANE_YZ \" , Plane ( Vector3 ( 1 , 0 , 0 ) , 0 ) ) ;", "msg": "Fixed Transform FLIP_Y and FLIP_Z set as identity transform\n"}
{"diff": "a / editor / editor_export . cpp \n  b / editor / editor_export . cpp \n void EditorExportPlatform : : gen_debug_flags ( Vector < String > & r_flags , int p_flags ) \n } \n \n Error EditorExportPlatform : : _save_pack_file ( void * p_userdata , const String & p_path , const Vector < uint8_t > & p_data , int p_file , int p_total ) { \n - if ( p_path . ends_with ( \" . so \" ) | | p_path . ends_with ( \" . dylib \" ) | | p_path . ends_with ( \" . dll \" ) ) \n - return OK ; \n \n PackData * pd = ( PackData * ) p_userdata ;", "msg": "EditorExport : Allow export plugins to add shared libraries\n"}
{"diff": "a / lib / Sema / CSSolver . cpp \n  b / lib / Sema / CSSolver . cpp \n ConstraintSystem : : solveImpl ( Expr * & expr , \n if ( convertType ) { \n auto constraintKind = ConstraintKind : : Conversion ; \n \n - if ( getContextualTypePurpose ( ) = = CTP_ReturnStmt \n + if ( ( getContextualTypePurpose ( ) = = CTP_ReturnStmt | | \n + getContextualTypePurpose ( ) = = CTP_ReturnSingleExpr ) \n & & Options . contains ( ConstraintSystemFlags : : UnderlyingTypeForOpaqueReturnType ) ) \n constraintKind = ConstraintKind : : OpaqueUnderlyingType ;", "msg": "Create opaque type constraint for single expr return . [ 49581931 ]\n"}
{"diff": "a / src / mongo / db / startup_warnings_mongod . cpp \n  b / src / mongo / db / startup_warnings_mongod . cpp \n void logMongodStartupWarnings ( const StorageGlobalParams & storageParams , \n warned = true ; \n } \n \n + / / Check if - - nojournal \n + bool isReplSet = replCoord - > getReplicationMode ( ) = = repl : : ReplicationCoordinator : : modeReplSet ; \n + if ( isReplSet & & storageParams . engine = = \" wiredTiger \" & & ! storageParams . dur ) { \n + log ( ) < < startupWarningsLog ; \n + log ( ) < < \" * * WARNING : Running wiredTiger with the - - nojournal option in a replica set \" \n + < < startupWarningsLog ; \n + log ( ) < < \" * * is deprecated and subject to be removed in a future version . \" \n + < < startupWarningsLog ; \n + warned = true ; \n + } \n + \n if ( warned ) { \n log ( ) < < startupWarningsLog ; \n }", "msg": "SERVER - 30760 Add startupWarning for WiredTiger - - nojournal\n"}
{"diff": "a / src / networkaccessmanager . cpp \n  b / src / networkaccessmanager . cpp \n NetworkAccessManager : : NetworkAccessManager ( QObject * parent , const Config * config \n , m_ignoreSslErrors ( config - > ignoreSslErrors ( ) ) \n , m_authAttempts ( 0 ) \n , m_maxAuthAttempts ( 3 ) \n + , m_resourceTimeout ( 0 ) \n , m_idCounter ( 0 ) \n , m_networkDiskCache ( 0 ) \n , m_sslConfiguration ( QSslConfiguration : : defaultConfiguration ( ) ) \n - , m_resourceTimeout ( 0 ) \n { \n setCookieJar ( CookieJar : : instance ( ) ) ;", "msg": "MINOR : Reorder initialisation order in NAM constr .\n"}
{"diff": "a / lib / SILOptimizer / Transforms / AllocBoxToStack . cpp \n  b / lib / SILOptimizer / Transforms / AllocBoxToStack . cpp \n static bool rewriteAllocBoxAsAllocStack ( AllocBoxInst * ABI ) { \n \n / / Promote this alloc_box to an alloc_stack . Insert the alloc_stack \n / / at the beginning of the function . \n - SILBuilder Builder ( ABI ) ; \n - Builder . setCurrentDebugScope ( ABI - > getDebugScope ( ) ) ; \n + SILBuilderWithScope Builder ( ABI ) ; \n assert ( ABI - > getBoxType ( ) - > getLayout ( ) - > getFields ( ) . size ( ) = = 1 \n & & \" rewriting multi - field box not implemented \" ) ; \n auto * ASI = Builder . createAllocStack (", "msg": "[ AllocBoxToStack ] Use ` SILBUilderWithScope ` instead of ` SILBuilder ` .\n"}
{"diff": "a / db / queryoptimizer . cpp \n  b / db / queryoptimizer . cpp \n namespace mongo { \n ss < < \" best guess plan requested , but scan and order required : \" ; \n ss < < \" query : \" < < query_ ; \n ss < < \" order : \" < < order_ ; \n - \n + ss < < \" choices : \" ; \n + for ( unsigned i = 0 ; i < plans_ . size ( ) ; i + + ) { \n + ss < < plans_ [ i ] - > indexKey ( ) < < \" \" ; \n + } \n + \n string s = ss . str ( ) ; \n msgassertedNoTrace ( 13284 , s . c_str ( ) ) ; \n }", "msg": "more debugging for SERVER - 1179\n"}
{"diff": "a / xbmc / interfaces / python / PythonInvoker . cpp \n  b / xbmc / interfaces / python / PythonInvoker . cpp \n extern \" C \" FILE * fopen_utf8 ( const char * _Filename , const char * _Mode ) ; \n using namespace XFILE ; \n using namespace KODI : : MESSAGING ; \n \n - extern \" C \" \n - { \n - int xbp_chdir ( const char * dirname ) ; \n - char * dll_getenv ( const char * szKey ) ; \n - } \n - \n # define PythonModulesSize sizeof ( PythonModules ) / sizeof ( PythonModule ) \n \n CCriticalSection CPythonInvoker : : s_critical ;", "msg": "[ cleanup ] remove unused functions\n"}
{"diff": "a / dbms / src / Common / Macros . cpp \n  b / dbms / src / Common / Macros . cpp \n \n # include < Poco / Util / AbstractConfiguration . h > \n # include < Common / Macros . h > \n # include < Common / Exception . h > \n + # include < IO / WriteHelpers . h > \n \n \n namespace DB \n String Macros : : expand ( const String & s , size_t level , const String & database_na \n else if ( macro_name = = \" table \" & & ! table_name . empty ( ) ) \n res + = table_name ; \n else \n - throw Exception ( \" No macro \" + macro_name + \" in config \" , ErrorCodes : : SYNTAX_ERROR ) ; \n + throw Exception ( \" No macro ' \" + macro_name + \n + \" ' in config while processing substitutions in ' \" + s + \" ' at \" \n + + toString ( begin ) , ErrorCodes : : SYNTAX_ERROR ) ; \n \n pos = end + 1 ; \n }", "msg": "More verbose error message in macros .\n"}
{"diff": "a / src / mongo / bson / mutable / document . cpp \n  b / src / mongo / bson / mutable / document . cpp \n namespace mutablebson { \n \" Attempt to add a sibling to an element without a parent \" ) ; \n \n ElementRep & parentRep = impl . getElementRep ( thisRep . parent ) ; \n - if ( impl . isLeaf ( parentRep ) ) \n - return Status ( \n - ErrorCodes : : IllegalOperation , \n - \" Attempt to add a sibling element under a non - object element \" ) ; \n + dassert ( ! impl . isLeaf ( parentRep ) ) ; \n \n impl . disableInPlaceUpdates ( ) ; \n \n namespace mutablebson { \n \" Attempt to add a sibling to an element without a parent \" ) ; \n \n ElementRep * parentRep = & impl . getElementRep ( thisRep - > parent ) ; \n - if ( impl . isLeaf ( * parentRep ) ) \n - return Status ( \n - ErrorCodes : : IllegalOperation , \n - \" Attempt to add a sibling element under a non - object element \" ) ; \n + dassert ( ! impl . isLeaf ( * parentRep ) ) ; \n \n impl . disableInPlaceUpdates ( ) ;", "msg": "SERVER - 8046 Remove some impossible error condition checks\n"}
{"diff": "a / xbmc / lib / libjsonrpc / JSONRPC . cpp \n  b / xbmc / lib / libjsonrpc / JSONRPC . cpp \n JSON_STATUS CJSONRPC : : Permission ( const CStdString & method , ITransportLayer * tran \n int flags = client - > GetPermissionFlags ( ) ; \n \n for ( int i = 1 ; i < = OPERATION_PERMISSION_ALL ; i * = 2 ) \n - { \n - if ( flags & i ) \n - result [ \" permission \" ] . append ( PermissionToString ( ( OperationPermission ) ( flags & i ) ) ) ; \n - } \n + result [ PermissionToString ( ( OperationPermission ) i ) ] = ( flags & i ) > 0 ; \n \n return OK ; \n }", "msg": "Made Permission return an object to be consistant with announcementflags\n"}
{"diff": "a / xbmc / cores / dvdplayer / DVDPlayer . cpp \n  b / xbmc / cores / dvdplayer / DVDPlayer . cpp \n bool CDVDPlayer : : OpenInputStream ( ) \n \n for ( unsigned int i = 0 ; i < filenames . size ( ) ; i + + ) \n { \n - CLog : : Log ( LOGERROR , \" test subs Amet [ % s ] \" , filenames [ i ] . c_str ( ) ) ; \n / / if vobsub subtitle : \n if ( URIUtils : : GetExtension ( filenames [ i ] ) = = \" . idx \" ) \n {", "msg": "cosmetics , remove some debug logging\n"}
{"diff": "a / hphp / compiler / expression / simple_function_call . cpp \n  b / hphp / compiler / expression / simple_function_call . cpp \n void SimpleFunctionCall : : analyzeProgram ( AnalysisResultPtr ar ) { \n } \n } \n if ( ! ok ) { \n - Compiler : : Error ( Compiler : : UnknownFunction , shared_from_this ( ) ) ; \n + if ( m_classScope | | ! Unit : : lookupFunc ( String ( m_name ) . get ( ) ) ) { \n + Compiler : : Error ( Compiler : : UnknownFunction , shared_from_this ( ) ) ; \n + } \n } \n } \n } \n ExpressionPtr hphp_opt_is_callable ( CodeGenerator * cg , \n } \n \n } \n -", "msg": "Don ' t warn for system functions that aren ' t known at static analysis time\n"}
{"diff": "a / hphp / runtime / base / program - functions . cpp \n  b / hphp / runtime / base / program - functions . cpp \n hugifyText ( char * from , char * to ) { \n } \n size_t sz = to - from ; \n \n + # ifdef FACEBOOK \n if ( RuntimeOption : : EvalNewTHPHotText ) { \n auto const hasKernelSupport = [ ] ( ) - > bool { \n KernelVersion version ; \n if ( version . m_major < 5 ) return false ; \n if ( version . m_major > 5 ) return true ; \n if ( version . m_minor > 2 ) return true ; \n - # ifdef FACEBOOK \n - if ( ( version . m_minor = = 2 ) & & ( version . m_minor > = 9 ) ) return true ; \n - # endif \n + if ( ( version . m_minor = = 2 ) & & ( version . m_fbk > = 1 ) ) return true ; \n return false ; \n } ; \n if ( hasKernelSupport ( ) ) { \n hugifyText ( char * from , char * to ) { \n return ; \n } \n } \n + # endif \n \n void * mem = malloc ( sz ) ; \n memcpy ( mem , from , sz ) ;", "msg": "use new hugify method only in fb builds\n"}
{"diff": "a / editor / project_export . cpp \n  b / editor / project_export . cpp \n void ProjectExportDialog : : _delete_preset_confirm ( ) { \n \n int idx = presets - > get_current ( ) ; \n _edit_preset ( - 1 ) ; \n + export_button - > set_disabled ( true ) ; \n EditorExport : : get_singleton ( ) - > remove_export_preset ( idx ) ; \n _update_presets ( ) ; \n }", "msg": "Disable Project Export button after deleting preset\n"}
{"diff": "a / Telegram / SourceFiles / historywidget . cpp \n  b / Telegram / SourceFiles / historywidget . cpp \n void HistoryWidget : : cancelEdit ( ) { \n updateMouseTracking ( ) ; \n } \n \n + int32 old = _textUpdateEventsFlags ; \n + _textUpdateEventsFlags = 0 ; \n onTextChange ( ) ; \n + _textUpdateEventsFlags = old ; \n + \n updateBotKeyboard ( ) ; \n updateFieldPlaceholder ( ) ;", "msg": "not sending typing when edit post is finished\n"}
{"diff": "a / xbmc / interfaces / python / xbmcmodule / window . cpp \n  b / xbmc / interfaces / python / xbmcmodule / window . cpp \n namespace PYXBMC \n Control * pControl = ( Control * ) object ; \n \n { \n - GilSafeSingleLock lock ( g_graphicsContext ) ; \n + CPyThreadState state ; \n + CSingleLock lock ( g_graphicsContext ) ; \n if ( ! self - > pWindow - > GetControl ( pControl - > iControlId ) ) \n { \n + lock . Leave ( ) ; \n + state . Restore ( ) ; \n PyErr_SetString ( PyExc_RuntimeError , \" Control does not exist in window \" ) ; \n return false ; \n }", "msg": "correct usage of CPyThreadState and g_graphicsContext locking in Window_RemoveSingleControl ( ensure we release both before accessing other python functions )\n"}
{"diff": "a / lib / AST / ArchetypeBuilder . cpp \n  b / lib / AST / ArchetypeBuilder . cpp \n bool ArchetypeBuilder : : addSuperclassRequirement ( PotentialArchetype * T , \n RequirementSource Source ) { \n T = T - > getRepresentative ( ) ; \n \n - if ( Superclass - > hasArchetype ( ) ) { \n - / / Map contextual type to interface type . \n - / / FIXME : There might be a better way to do this . \n - Superclass = Superclass . transform ( \n - [ & ] ( Type t ) - > Type { \n - if ( t - > is < ArchetypeType > ( ) ) { \n - auto * pa = resolveArchetype ( t ) ; \n - / / Why does this happen ? \n - if ( ! pa ) \n - return ErrorType : : get ( t ) ; \n - return pa - > getDependentType ( / * FIXME : * / { } , \n - / * allowUnresolved = * / false ) ; \n - } \n - return t ; \n - } ) ; \n - } \n - \n / / Make sure the concrete type fulfills the superclass requirement \n / / of the archetype . \n if ( T - > isConcreteType ( ) ) {", "msg": "[ Archetype builder ] Remove some dead code . NFC\n"}
{"diff": "a / xbmc / video / VideoDatabase . cpp \n  b / xbmc / video / VideoDatabase . cpp \n void CVideoDatabase : : CleanDatabase ( CGUIDialogProgressBarHandle * handle , const se \n { \n std : : map < int , bool > : : const_iterator pathsDeleteDecision = pathsDeleteDecisions . find ( m_pDS - > fv ( 0 ) . get_asInt ( ) ) ; \n if ( ( pathsDeleteDecision ! = pathsDeleteDecisions . end ( ) & & pathsDeleteDecision - > second ) | | \n - ( pathsDeleteDecision = = pathsDeleteDecisions . end ( ) & & ! CDirectory : : Exists ( m_pDS - > fv ( 1 ) . get_asString ( ) ) ) ) \n + ( pathsDeleteDecision = = pathsDeleteDecisions . end ( ) & & ! CDirectory : : Exists ( m_pDS - > fv ( 1 ) . get_asString ( ) , false ) ) ) \n strIds + = m_pDS - > fv ( 0 ) . get_asString ( ) + \" , \" ; \n \n m_pDS - > next ( ) ;", "msg": "videodb : never use cached lookups during database cleaning\n"}
{"diff": "a / src / mongo / db / d_concurrency . cpp \n  b / src / mongo / db / d_concurrency . cpp \n namespace mongo { \n static void unlocking_w ( ) ; \n static void unlocking_W ( ) ; \n \n - class WrapperForTiming { \n + class WrapperForQLock { \n QLock q ; \n public : \n LockStat stats ; \n namespace mongo { \n bool R_to_W ( ) { return q . R_to_W ( ) ; } \n } ; \n \n - static WrapperForTiming & q = * new WrapperForTiming ( ) ; \n + static WrapperForQLock & q = * new WrapperForQLock ( ) ; \n \n void reportLockStats ( BSONObjBuilder & result ) { \n BSONObjBuilder b ;", "msg": "change WrapperForTiming to WrapperForQLock\n"}
{"diff": "a / xbmc / cores / dvdplayer / DVDPlayer . cpp \n  b / xbmc / cores / dvdplayer / DVDPlayer . cpp \n bool CDVDPlayer : : HasMenu ( ) \n \n bool CDVDPlayer : : GetCurrentSubtitle ( CStdString & strSubtitle ) \n { \n - double pts = m_clock . GetClock ( ) ; \n + double pts = m_clock . GetClock ( ) + m_State . time_offset ; \n \n - if ( m_pInputStream & & m_pInputStream - > IsStreamType ( DVDSTREAM_TYPE_DVD ) ) \n + if ( m_pInputStream & & m_pInputStream - > IsStreamType ( DVDSTREAM_TYPE_DVD ) & & m_CurrentSubtitle . source ! = STREAM_SOURCE_TEXT ) \n return false ; \n \n m_dvdPlayerSubtitle . GetCurrentSubtitle ( strSubtitle , pts - m_dvdPlayerVideo . GetSubtitleDelay ( ) ) ;", "msg": "[ fix ] Allow the use of external subtitles for DVDs\n"}
{"diff": "a / tools / sil - opt / SILOpt . cpp \n  b / tools / sil - opt / SILOpt . cpp \n EnableResilience ( \" enable - resilience \" , \n \" interfaces for all public declarations by \" \n \" default \" ) ) ; \n \n + static llvm : : cl : : opt < bool > \n + EnableSILOwnershipOpt ( \" enable - sil - ownership \" , \n + llvm : : cl : : desc ( \" Compile the module with sil - ownership initially enabled for all functions \" ) ) ; \n + \n static llvm : : cl : : opt < std : : string > \n ResourceDir ( \" resource - dir \" , \n llvm : : cl : : desc ( \" The directory that holds the compiler resource files \" ) ) ; \n int main ( int argc , char * * argv ) { \n SILOpts . AssertConfig = AssertConfId ; \n if ( OptimizationGroup ! = OptGroup : : Diagnostics ) \n SILOpts . Optimization = SILOptions : : SILOptMode : : Optimize ; \n - \n + SILOpts . EnableSILOwnership = EnableSILOwnershipOpt ; \n \n / / Load the input file . \n llvm : : ErrorOr < std : : unique_ptr < llvm : : MemoryBuffer > > FileBufOrErr =", "msg": "[ semantic - arc ] Add an option to SILOpt to set the EnableSILOwnership flag .\n"}
{"diff": "a / xbmc / video / VideoDatabase . cpp \n  b / xbmc / video / VideoDatabase . cpp \n bool CVideoDatabase : : GetItemsForPath ( const CStdString & content , const CStdString \n GetMusicVideosByWhere ( \" \" , where , items ) ; \n } \n for ( int i = 0 ; i < items . Size ( ) ; i + + ) \n - items [ i ] - > SetPath ( items [ i ] - > GetVideoInfoTag ( ) - > m_strFileNameAndPath ) ; \n + items [ i ] - > SetPath ( items [ i ] - > GetVideoInfoTag ( ) - > m_basePath ) ; \n return items . Size ( ) > 0 ; \n }", "msg": "Revert \" fixed : Better fix for bccb52dd1fb708959a4cf93e14761178b337182a - Video metadata would not show in the video files node for stacked files ( thanks Jonathan for all the pointers ) \"\n"}
{"diff": "a / Code / CryPlugins / CryDefaultEntities / Module / DefaultComponents / Physics / RigidBodyComponent . cpp \n  b / Code / CryPlugins / CryDefaultEntities / Module / DefaultComponents / Physics / RigidBodyComponent . cpp \n void CRigidBodyComponent : : Physicalize ( ) \n { \n SEntityPhysicalizeParams physParams ; \n physParams . type = ( int ) m_type ; \n + \n + Enable ( m_isEnabledByDefault ) ; \n \n / / Don ' t physicalize a slot by default \n physParams . nSlot = std : : numeric_limits < int > : : max ( ) ; \n void CRigidBodyComponent : : Physicalize ( ) \n buoyancyParams . waterDamping = m_buoyancyParameters . damping ; \n m_pEntity - > GetPhysicalEntity ( ) - > SetParams ( & buoyancyParams ) ; \n \n - Enable ( m_isEnabledByDefault ) ; \n } \n \n void CRigidBodyComponent : : ProcessEvent ( const SEntityEvent & event )", "msg": "! I 1843114 / / ce / main_stabilisation - > / / ce / main ! B ( CE - 18107 ) ( CryDefaultEntities ) Rigidbody component ' s \" Enabled by Default \" property can ' t be re - enabled\n"}
{"diff": "a / src / ExportCsvDialog . cpp \n  b / src / ExportCsvDialog . cpp \n bool ExportCsvDialog : : exportQuery ( const QString & sQuery , const QString & sFilenam \n QChar quoteChar = currentQuoteChar ( ) ; \n QString quotequoteChar = QString ( quoteChar ) + quoteChar ; \n QChar sepChar = currentSeparatorChar ( ) ; \n + \n + / / Choose appropriate newline character for the platform \n + # ifdef Q_OS_WIN \n QString newlineChar = \" \\ r \\ n \" ; \n + # else \n + QString newlineChar = \" \\ n \" ; \n + # endif \n \n / / chars that require escaping \n std : : string special_chars = newlineChar . toStdString ( ) + sepChar . toLatin1 ( ) + quoteChar . toLatin1 ( ) ;", "msg": "Change the newline character for CSV export depending upon the platform\n"}
{"diff": "a / samples / Javascript / TestJavascript / Classes / AppDelegate . cpp \n  b / samples / Javascript / TestJavascript / Classes / AppDelegate . cpp \n bool AppDelegate : : applicationDidFinishLaunching ( ) \n Director * pDirector = Director : : sharedDirector ( ) ; \n pDirector - > setOpenGLView ( EGLView : : sharedOpenGLView ( ) ) ; \n \n + / / JS - Test in Html5 uses 800x450 as design resolution \n + EGLView : : sharedOpenGLView ( ) - > setDesignResolutionSize ( 800 , 450 , kResolutionFixedHeight ) ; \n / / turn on display FPS \n pDirector - > setDisplayStats ( true ) ;", "msg": "issue : Using 800x450 as design resolution for TestJavascript .\n"}
{"diff": "a / dbms / src / Parsers / ASTAlterQuery . cpp \n  b / dbms / src / Parsers / ASTAlterQuery . cpp \n void ASTAlterQuery : : addParameters ( const Parameters & params ) \n children . push_back ( params . sharding_key_expr ) ; \n if ( params . coordinator ) \n children . push_back ( params . coordinator ) ; \n + if ( params . primary_key ) \n + children . push_back ( params . primary_key ) ; \n } \n \n ASTAlterQuery : : ASTAlterQuery ( StringRange range_ ) : IAST ( range_ )", "msg": "Alter primary key : development [ # METR - 21119 ] .\n"}
{"diff": "a / scene / gui / scroll_bar . cpp \n  b / scene / gui / scroll_bar . cpp \n void ScrollBar : : _notification ( int p_what ) { \n \n if ( Math : : abs ( vel ) > = dist ) { \n set_value ( target_scroll ) ; \n + scrolling = false ; \n + set_physics_process_internal ( false ) ; \n } else { \n set_value ( get_value ( ) + vel ) ; \n }", "msg": "Fix scroll bar lock when smooth scroll enabled , issue 23314\n"}
{"diff": "a / xbmc / video / windows / GUIWindowVideoNav . cpp \n  b / xbmc / video / windows / GUIWindowVideoNav . cpp \n void CGUIWindowVideoNav : : LoadVideoInfo ( CFileItemList & items , CVideoDatabase & dat \n CFileItemPtr pItem = items [ i ] ; \n CFileItemPtr match ; \n \n - if ( ! content . empty ( ) & & pItem - > m_bIsFolder & & ! pItem - > IsParentFolder ( ) ) \n + if ( pItem - > m_bIsFolder & & ! pItem - > IsParentFolder ( ) ) \n { \n / / we need this for enabling the right context menu entries , like mark watched / unwatched \n pItem - > SetProperty ( \" IsVideoFolder \" , true ) ;", "msg": "[ video ] Re - add ' Mark watched / unwatched ' context menu items to content - less video sources .\n"}
